// Prisma Schema for SSA Intelligence Research Platform
// Uses PostgreSQL with new section naming convention

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Main research job - tracks complete company intelligence generation
model ResearchJob {
  id                String    @id @default(cuid())
  
  // Job status
  status            String    // 'queued' | 'pending' | 'running' | 'completed' | 'failed'
  currentStage      String?   // Current stage being executed
  progress          Float     @default(0) // 0.0 to 1.0
  queuedAt          DateTime  @default(now())
  startedAt         DateTime?
  
  // Research inputs
  companyName       String
  normalizedCompany String
  geography         String
  normalizedGeography String
  industry          String?
  normalizedIndustry String?
  domain            String?
  normalizedDomain  String?
  focusAreas        String[]  @default([])
  reportType        ReportType @default(GENERIC)
  selectedSections  String[]  @default([])
  userAddedPrompt   String?
  visibilityScope   VisibilityScope @default(PRIVATE)
  
  // Research outputs (stored as JSON matching TypeScript interfaces)
  foundation            Json?  // FoundationOutput
  execSummary           Json?  // Section1Output (renamed for consistency)
  financialSnapshot     Json?  // Section2Output
  companyOverview       Json?  // Section3Output
  segmentAnalysis       Json?  // Section4Output
  trends                Json?  // Section5Output
  peerBenchmarking      Json?  // Section6Output
  skuOpportunities      Json?  // Section7Output
  recentNews            Json?  // Section8Output
  conversationStarters  Json?  // Section9Output
  appendix              Json?  // Section10Output
  
  // Metadata
  overallConfidence String?   // 'HIGH' | 'MEDIUM' | 'LOW'
  overallConfidenceScore Float?
  metadata          Json      @default("{}") // Additional context (user files, etc.)
  
  // Relations
  subJobs           ResearchSubJob[]
  jobGroups         ResearchJobGroup[]
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String
  
  // Token usage and cost tracking
  promptTokens      Int       @default(0)
  completionTokens  Int       @default(0)
  costUsd           Float     @default(0)
  thumbnailUrl      String?

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  completedAt       DateTime?
  
  @@index([userId, status])
  @@index([createdAt])
  @@index([status])
  @@index([status, queuedAt])
  @@index([normalizedDomain])
  @@index([reportType])
  @@index([visibilityScope])
  @@unique([userId, normalizedCompany, normalizedGeography, normalizedIndustry, reportType])
}

// Individual section/stage execution tracking
model ResearchSubJob {
  id           String      @id @default(cuid())
  
  // Parent job
  researchId   String
  research     ResearchJob @relation(fields: [researchId], references: [id], onDelete: Cascade)
  
  // Stage information (using app naming convention)
  stage        String      // 'foundation' | 'exec_summary' | 'financial_snapshot' | etc.
  status       String      // 'pending' | 'running' | 'completed' | 'failed'
  dependencies String[]    // Array of stage names this depends on
  
  // Execution tracking
  attempts     Int         @default(0)
  maxAttempts  Int         @default(3)
  lastError    String?
  promptTokens     Int     @default(0)
  completionTokens Int     @default(0)
  costUsd          Float   @default(0)
  
  // Output data
  output       Json?       // Section-specific output
  confidence   String?     // 'HIGH' | 'MEDIUM' | 'LOW'
  sourcesUsed  String[]    @default([]) // ["S1", "S2", "S3"]
  
  // Timing
  startedAt    DateTime?
  completedAt  DateTime?
  duration     Int?        // Milliseconds
  
  // Timestamps
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  @@unique([researchId, stage])
  @@index([researchId, status])
  @@index([status])
}

// User model
model User {
  id        String        @id @default(cuid())
  email     String        @unique
  name      String?
  role      UserRole      @default(MEMBER)
  
  // Relations
  research  ResearchJob[]
  memberships GroupMembership[]
  
  // Timestamps
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  
  @@index([email])
}

model Group {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships GroupMembership[]
  jobGroups   ResearchJobGroup[]

  @@index([name])
}

model GroupMembership {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([groupId])
  @@index([userId])
}

model ResearchJobGroup {
  id        String   @id @default(cuid())
  jobId     String
  groupId   String
  createdAt DateTime @default(now())

  job   ResearchJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  group Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([jobId, groupId])
  @@index([groupId])
  @@index([jobId])
}

enum UserRole {
  ADMIN
  MEMBER
}

enum VisibilityScope {
  PRIVATE
  GROUP
  GENERAL
}

enum ReportType {
  GENERIC
  INDUSTRIALS
  PE
  FS
}

// Optional: API Key management for users
model ApiKey {
  id        String   @id @default(cuid())
  key       String   @unique
  name      String
  userId    String
  lastUsed  DateTime?
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([key])
}

// User feedback submissions
model Feedback {
  id         String   @id @default(cuid())
  name       String?
  email      String?
  message    String
  pagePath   String?
  reportId   String?
  createdAt  DateTime @default(now())

  @@index([createdAt])
}

// ============================================================================
// NEWS INTELLIGENCE MODELS
// ============================================================================

enum TagCategory {
  universal
  pe
  industrials
}

enum ArticlePriority {
  high
  medium
  low
}

enum ArticleStatus {
  new_article @map("new")
  update
}

enum MatchType {
  exact
  contextual
}

enum FetchLayer {
  layer1_rss
  layer1_api
  layer2_llm
}

// Revenue Owner - person who tracks companies/people for news
model RevenueOwner {
  id        String   @id @default(cuid())
  name      String
  email     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companies CallDietCompany[]
  people    CallDietPerson[]
  tags      CallDietTag[]
  articles  ArticleRevenueOwner[]

  @@map("revenue_owners")
}

// Companies being tracked for news
model TrackedCompany {
  id        String   @id @default(cuid())
  name      String
  ticker    String?
  cik       String?  // SEC Central Index Key for EDGAR filings
  createdAt DateTime @default(now())

  callDiets CallDietCompany[]
  articles  NewsArticle[]

  @@map("tracked_companies")
}

// People being tracked for news
model TrackedPerson {
  id                 String   @id @default(cuid())
  name               String
  title              String?
  companyAffiliation String?  @map("company_affiliation")
  createdAt          DateTime @default(now())

  callDiets CallDietPerson[]
  articles  NewsArticle[]

  @@map("tracked_people")
}

// Tags/Topics for categorizing news
model NewsTag {
  id        String      @id @default(cuid())
  name      String      @unique
  category  TagCategory
  createdAt DateTime    @default(now())

  callDiets CallDietTag[]
  articles  NewsArticle[]

  @@map("news_tags")
}

// Junction: Revenue Owner <-> Company
model CallDietCompany {
  revenueOwner   RevenueOwner   @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  company        TrackedCompany @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId      String

  @@id([revenueOwnerId, companyId])
  @@map("call_diet_companies")
}

// Junction: Revenue Owner <-> Person
model CallDietPerson {
  revenueOwner   RevenueOwner  @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  person         TrackedPerson @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId       String

  @@id([revenueOwnerId, personId])
  @@map("call_diet_people")
}

// Junction: Revenue Owner <-> Tag
model CallDietTag {
  revenueOwner   RevenueOwner @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  tag            NewsTag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId          String

  @@id([revenueOwnerId, tagId])
  @@map("call_diet_tags")
}

// News Articles fetched via hybrid Layer 1/Layer 2 approach
model NewsArticle {
  id            String           @id @default(cuid())
  headline      String
  shortSummary  String?          @map("short_summary")  // 1-2 sentence preview
  longSummary   String?          @map("long_summary")   // 3-5 sentence detailed summary
  summary       String?          // Legacy field, kept for compatibility
  whyItMatters  String?          @map("why_it_matters")
  publishedAt   DateTime?        @map("published_at")
  fetchedAt     DateTime         @default(now()) @map("fetched_at")
  priority      ArticlePriority?
  priorityScore Int?             @map("priority_score") // 1-10 for sorting (hidden)
  status        ArticleStatus?
  matchType     MatchType?       @map("match_type")
  fetchLayer    FetchLayer?      @map("fetch_layer")
  rawContent    String?          @map("raw_content")
  isSent        Boolean          @default(false) @map("is_sent") // Sent to client status

  // Primary source (for backward compatibility)
  sourceUrl    String           @unique @map("source_url")
  sourceName   String?          @map("source_name")

  // Scraped full content (high-priority articles only)
  fullContent    String?   @map("full_content")
  contentScraped Boolean   @default(false) @map("content_scraped")
  scrapedAt      DateTime? @map("scraped_at")

  company      TrackedCompany?  @relation(fields: [companyId], references: [id])
  companyId    String?          @map("company_id")
  person       TrackedPerson?   @relation(fields: [personId], references: [id])
  personId     String?          @map("person_id")
  tag          NewsTag?         @relation(fields: [tagId], references: [id])
  tagId        String?          @map("tag_id")

  revenueOwners ArticleRevenueOwner[]
  sources       ArticleSource[]  // Multiple sources for merged stories

  @@index([publishedAt(sort: Desc)])
  @@index([priority])
  @@index([priorityScore(sort: Desc)])
  @@index([companyId])
  @@index([tagId])
  @@index([isSent])
  @@map("news_articles")
}

// Multiple sources for a single article (when stories are merged)
model ArticleSource {
  id         String      @id @default(cuid())
  article    NewsArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  articleId  String      @map("article_id")
  sourceUrl  String      @map("source_url")
  sourceName String      @map("source_name")
  fetchLayer FetchLayer? @map("fetch_layer")
  fetchedAt  DateTime    @default(now()) @map("fetched_at")

  @@unique([articleId, sourceUrl])
  @@index([articleId])
  @@map("article_sources")
}

// Junction: Article <-> Revenue Owner (many-to-many)
model ArticleRevenueOwner {
  article        NewsArticle  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  articleId      String       @map("article_id")
  revenueOwner   RevenueOwner @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String       @map("revenue_owner_id")

  @@id([articleId, revenueOwnerId])
  @@map("article_revenue_owners")
}

// URL deduplication tracking
model SeenUrl {
  urlHash   String   @id @map("url_hash")
  url       String
  firstSeen DateTime @default(now()) @map("first_seen")

  @@map("seen_urls")
}

// System configuration key-value store
model NewsConfig {
  key   String @id
  value String

  @@map("news_config")
}
