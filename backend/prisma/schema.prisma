// Prisma Schema for SSA Intelligence Research Platform
// Uses PostgreSQL with new section naming convention

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Main research job - tracks complete company intelligence generation
model ResearchJob {
  id                String    @id @default(cuid())
  
  // Job status
  status            String    // 'queued' | 'pending' | 'running' | 'completed' | 'failed'
  currentStage      String?   // Current stage being executed
  progress          Float     @default(0) // 0.0 to 1.0
  queuedAt          DateTime  @default(now())
  startedAt         DateTime?
  
  // Research inputs
  companyName       String
  normalizedCompany String
  geography         String
  normalizedGeography String
  industry          String?
  normalizedIndustry String?
  domain            String?
  normalizedDomain  String?
  focusAreas        String[]  @default([])
  reportType        ReportType @default(GENERIC)
  selectedSections  String[]  @default([])
  userAddedPrompt   String?
  visibilityScope   VisibilityScope @default(PRIVATE)
  
  // Research outputs (stored as JSON matching TypeScript interfaces)
  foundation            Json?  // FoundationOutput
  execSummary           Json?  // Section1Output (renamed for consistency)
  financialSnapshot     Json?  // Section2Output
  companyOverview       Json?  // Section3Output
  segmentAnalysis       Json?  // Section4Output
  trends                Json?  // Section5Output
  peerBenchmarking      Json?  // Section6Output
  skuOpportunities      Json?  // Section7Output
  recentNews            Json?  // Section8Output
  conversationStarters  Json?  // Section9Output
  appendix              Json?  // Section10Output
  
  // Metadata
  overallConfidence String?   // 'HIGH' | 'MEDIUM' | 'LOW'
  overallConfidenceScore Float?
  metadata          Json      @default("{}") // Additional context (user files, etc.)
  
  // Relations
  subJobs           ResearchSubJob[]
  jobGroups         ResearchJobGroup[]
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String
  
  // Token usage and cost tracking
  promptTokens      Int       @default(0)
  completionTokens  Int       @default(0)
  costUsd           Float     @default(0)
  thumbnailUrl      String?

  // Cost events relation
  costEvents        CostEvent[]

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  completedAt       DateTime?
  
  @@index([userId, status])
  @@index([createdAt])
  @@index([completedAt])
  @@index([status])
  @@index([status, queuedAt])
  @@index([normalizedDomain])
  @@index([reportType])
  @@index([visibilityScope])
  @@unique([userId, normalizedCompany, normalizedGeography, normalizedIndustry, reportType])
}

// Individual section/stage execution tracking
model ResearchSubJob {
  id           String      @id @default(cuid())
  
  // Parent job
  researchId   String
  research     ResearchJob @relation(fields: [researchId], references: [id], onDelete: Cascade)
  
  // Stage information (using app naming convention)
  stage        String      // 'foundation' | 'exec_summary' | 'financial_snapshot' | etc.
  status       String      // 'pending' | 'running' | 'completed' | 'failed'
  dependencies String[]    // Array of stage names this depends on
  
  // Execution tracking
  attempts     Int         @default(0)
  maxAttempts  Int         @default(3)
  lastError    String?
  promptTokens     Int     @default(0)
  completionTokens Int     @default(0)
  costUsd          Float   @default(0)
  
  // Output data
  output       Json?       // Section-specific output
  confidence   String?     // 'HIGH' | 'MEDIUM' | 'LOW'
  sourcesUsed  String[]    @default([]) // ["S1", "S2", "S3"]
  
  // Timing
  startedAt    DateTime?
  completedAt  DateTime?
  duration     Int?        // Milliseconds
  
  // Timestamps
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  @@unique([researchId, stage])
  @@index([researchId, status])
  @@index([status])
}

// User model
model User {
  id        String        @id @default(cuid())
  email     String        @unique
  name      String?
  role      UserRole      @default(MEMBER)
  
  // Relations
  research  ResearchJob[]
  memberships GroupMembership[]
  
  // Timestamps
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  
  @@index([email])
}

model Group {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships GroupMembership[]
  jobGroups   ResearchJobGroup[]

  @@index([name])
}

model GroupMembership {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([groupId])
  @@index([userId])
}

model ResearchJobGroup {
  id        String   @id @default(cuid())
  jobId     String
  groupId   String
  createdAt DateTime @default(now())

  job   ResearchJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  group Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([jobId, groupId])
  @@index([groupId])
  @@index([jobId])
}

enum UserRole {
  ADMIN
  MEMBER
}

enum VisibilityScope {
  PRIVATE
  GROUP
  GENERAL
}

enum ReportType {
  GENERIC
  INDUSTRIALS
  PE
  FS
  INSURANCE
}

// Bug tracker enums
enum FeedbackType {
  bug
  issue
  feature
  other
}

enum FeedbackStatus {
  new_feedback @map("new")
  reviewed
  in_progress
  resolved
  wont_fix
}

// Optional: API Key management for users
model ApiKey {
  id        String   @id @default(cuid())
  key       String   @unique
  name      String
  userId    String
  lastUsed  DateTime?
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([key])
}

// User feedback / bug tracker submissions
model Feedback {
  id              String          @id @default(cuid())
  type            FeedbackType    @default(other)
  title           String?
  message         String          // Description/body of the feedback
  name            String?
  email           String?
  pagePath        String?         @map("page_path")
  reportId        String?         @map("report_id")
  status          FeedbackStatus  @default(new_feedback)
  resolutionNotes String?         @map("resolution_notes")
  resolvedAt      DateTime?       @map("resolved_at")
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([createdAt])
  @@index([type])
  @@index([status])
}

// ============================================================================
// NEWS INTELLIGENCE MODELS
// ============================================================================

enum TagCategory {
  universal
  pe
  industrials
}

enum ArticleStatus {
  new_article @map("new")
  update
}

enum MatchType {
  exact
  contextual
}

enum FetchLayer {
  layer1_rss
  layer1_api
  layer2_llm
}

// Revenue Owner - person who tracks companies/people for news
model RevenueOwner {
  id        String   @id @default(cuid())
  name      String
  email     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companies CallDietCompany[]
  people    CallDietPerson[]
  tags      CallDietTag[]
  articles  ArticleRevenueOwner[]

  @@map("revenue_owners")
}

// Companies being tracked for news
model TrackedCompany {
  id        String   @id @default(cuid())
  name      String
  ticker    String?
  cik       String?  // SEC Central Index Key for EDGAR filings
  createdAt DateTime @default(now())

  callDiets CallDietCompany[]
  articles  NewsArticle[]

  @@map("tracked_companies")
}

// People being tracked for news
model TrackedPerson {
  id                 String   @id @default(cuid())
  name               String
  title              String?
  companyAffiliation String?  @map("company_affiliation")
  createdAt          DateTime @default(now())

  callDiets CallDietPerson[]
  articles  NewsArticle[]

  @@map("tracked_people")
}

// Tags/Topics for categorizing news
model NewsTag {
  id        String      @id @default(cuid())
  name      String      @unique
  category  TagCategory
  createdAt DateTime    @default(now())

  callDiets CallDietTag[]
  articles  NewsArticle[]

  @@map("news_tags")
}

// Junction: Revenue Owner <-> Company
model CallDietCompany {
  revenueOwner   RevenueOwner   @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  company        TrackedCompany @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId      String

  @@id([revenueOwnerId, companyId])
  @@map("call_diet_companies")
}

// Junction: Revenue Owner <-> Person
model CallDietPerson {
  revenueOwner   RevenueOwner  @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  person         TrackedPerson @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId       String

  @@id([revenueOwnerId, personId])
  @@map("call_diet_people")
}

// Junction: Revenue Owner <-> Tag
model CallDietTag {
  revenueOwner   RevenueOwner @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String
  tag            NewsTag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId          String

  @@id([revenueOwnerId, tagId])
  @@map("call_diet_tags")
}

// News Articles fetched via hybrid Layer 1/Layer 2 approach
model NewsArticle {
  id            String           @id @default(cuid())
  headline      String
  shortSummary  String?          @map("short_summary")  // 1-2 sentence preview
  longSummary   String?          @map("long_summary")   // 3-5 sentence detailed summary
  summary       String?          // Legacy field, kept for compatibility
  whyItMatters  String?          @map("why_it_matters")
  publishedAt   DateTime?        @map("published_at")
  fetchedAt     DateTime         @default(now()) @map("fetched_at")
  status        ArticleStatus?
  matchType     MatchType?       @map("match_type")
  fetchLayer    FetchLayer?      @map("fetch_layer")
  rawContent    String?          @map("raw_content")
  isSent        Boolean          @default(false) @map("is_sent")
  isArchived    Boolean          @default(false) @map("is_archived")

  // Primary source (for backward compatibility)
  sourceUrl    String           @unique @map("source_url")
  sourceName   String?          @map("source_name")

  // Scraped full content
  fullContent    String?   @map("full_content")
  contentScraped Boolean   @default(false) @map("content_scraped")
  scrapedAt      DateTime? @map("scraped_at")

  company      TrackedCompany?  @relation(fields: [companyId], references: [id])
  companyId    String?          @map("company_id")
  person       TrackedPerson?   @relation(fields: [personId], references: [id])
  personId     String?          @map("person_id")
  tag          NewsTag?         @relation(fields: [tagId], references: [id])
  tagId        String?          @map("tag_id")

  revenueOwners ArticleRevenueOwner[]
  sources       ArticleSource[]  // Multiple sources for merged stories

  @@index([publishedAt(sort: Desc)])
  @@index([companyId])
  @@index([tagId])
  @@index([isSent])
  @@index([isArchived])
  @@map("news_articles")
}

// Multiple sources for a single article (when stories are merged)
model ArticleSource {
  id         String      @id @default(cuid())
  article    NewsArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  articleId  String      @map("article_id")
  sourceUrl  String      @map("source_url")
  sourceName String      @map("source_name")
  fetchLayer FetchLayer? @map("fetch_layer")
  fetchedAt  DateTime    @default(now()) @map("fetched_at")

  @@unique([articleId, sourceUrl])
  @@index([articleId])
  @@map("article_sources")
}

// Junction: Article <-> Revenue Owner (many-to-many)
model ArticleRevenueOwner {
  article        NewsArticle  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  articleId      String       @map("article_id")
  revenueOwner   RevenueOwner @relation(fields: [revenueOwnerId], references: [id], onDelete: Cascade)
  revenueOwnerId String       @map("revenue_owner_id")

  @@id([articleId, revenueOwnerId])
  @@map("article_revenue_owners")
}

// URL deduplication tracking
model SeenUrl {
  urlHash   String   @id @map("url_hash")
  url       String
  firstSeen DateTime @default(now()) @map("first_seen")

  @@map("seen_urls")
}

// System configuration key-value store
model NewsConfig {
  key   String @id
  value String

  @@map("news_config")
}

// ============================================================================
// PROMPT LIBRARY MODELS
// ============================================================================

// Admin-editable prompt overrides
model Prompt {
  id            String       @id @default(cuid())
  sectionId     String       // 'foundation', 'exec_summary', etc.
  reportType    ReportType?  // null = base prompt, or specific type for addendum

  name          String       // Human-readable name
  description   String?      // Admin notes
  content       String       @db.Text

  status        PromptStatus @default(draft)
  version       Int          @default(1)

  createdBy     String?
  updatedBy     String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  publishedAt   DateTime?

  @@unique([sectionId, reportType, version])
  @@index([sectionId, reportType, status])
  @@map("prompts")
}

// Version history for prompts
model PromptVersion {
  id            String   @id @default(cuid())
  sectionId     String
  reportType    ReportType?
  version       Int
  content       String   @db.Text
  createdBy     String?
  createdAt     DateTime @default(now())

  @@unique([sectionId, reportType, version])
  @@index([sectionId, reportType])
  @@map("prompt_versions")
}

// Prompt test execution tracking
model PromptTestRun {
  id            String    @id @default(cuid())
  sectionId     String
  reportType    ReportType?
  promptContent String    @db.Text

  companyName   String
  geography     String

  status        String    // 'running' | 'completed' | 'failed'
  output        Json?
  error         String?

  inputTokens   Int       @default(0)
  outputTokens  Int       @default(0)
  costUsd       Float     @default(0)
  durationMs    Int?

  createdBy     String
  createdAt     DateTime  @default(now())
  completedAt   DateTime?

  @@index([sectionId])
  @@map("prompt_test_runs")
}

enum PromptStatus {
  draft
  published
  archived
}

// ============================================================================
// COST TRACKING & METRICS MODELS
// ============================================================================

// Admin-editable pricing rates for LLM API calls
model PricingRate {
  id              String    @id @default(cuid())
  provider        String    // "anthropic"
  model           String    // "claude-sonnet-4-5"
  inputRate       Float     // USD per 1M tokens
  outputRate      Float     // USD per 1M tokens
  cacheReadRate   Float     @default(0) // USD per 1M tokens (cache hits)
  cacheWriteRate  Float     @default(0) // USD per 1M tokens (cache writes)
  effectiveFrom   DateTime  @default(now())
  effectiveTo     DateTime? // null = currently active
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([provider, model, effectiveFrom])
  @@index([provider, model])
  @@index([effectiveFrom])
  @@map("pricing_rates")
}

// Granular cost tracking per API call
model CostEvent {
  id               String       @id @default(cuid())
  jobId            String?      // null for pre-job costs
  subJobId         String?      // null for non-stage costs
  draftId          String?      // client-generated ID for pre-job linkage
  stage            String       // "company_resolution", "domain_inference", "foundation", etc.
  provider         String       // "anthropic"
  model            String       // "claude-sonnet-4-5"
  inputTokens      Int          @default(0)
  outputTokens     Int          @default(0)
  cacheReadTokens  Int          @default(0)
  cacheWriteTokens Int          @default(0)
  costUsd          Float        @default(0)
  metadata         Json         @default("{}")
  createdAt        DateTime     @default(now())

  job              ResearchJob? @relation(fields: [jobId], references: [id], onDelete: SetNull)

  @@index([jobId])
  @@index([draftId])
  @@index([stage])
  @@index([createdAt])
  @@map("cost_events")
}
