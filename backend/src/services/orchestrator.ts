/**
 * Job Orchestrator
 * Manages research job execution with dependency resolution and parallel processing
 */

import { PrismaClient } from '@prisma/client';
import { getClaudeClient } from './claude-client';
import { createSourceCatalog, type SourceCatalogManager } from './source-resolver';
import type { FoundationOutput } from '../types/prompts';

// Import prompt builders (these will be renamed section files)
import { buildFoundationPrompt } from '../../prompts/foundation-prompt';
import { buildExecSummaryPrompt } from '../../prompts/exec-summary';
import { buildFinancialSnapshotPrompt } from '../../prompts/financial-snapshot';
import { buildCompanyOverviewPrompt } from '../../prompts/company-overview';
import { buildSegmentAnalysisPrompt } from '../../prompts/segment-analysis';
import { buildTrendsPrompt } from '../../prompts/trends';
import { buildPeerBenchmarkingPrompt } from '../../prompts/peer-benchmarking';
import { buildSkuOpportunitiesPrompt } from '../../prompts/sku-opportunities';
import { buildRecentNewsPrompt } from '../../prompts/recent-news';
import { buildConversationStartersPrompt } from '../../prompts/conversation-starters';
import { generateAppendix } from '../../prompts/appendix';

// Import validation schemas
import {
  foundationOutputSchema,
  execSummaryOutputSchema,
  financialSnapshotOutputSchema,
  companyOverviewOutputSchema,
  segmentAnalysisOutputSchema,
  trendsOutputSchema,
  peerBenchmarkingOutputSchema,
  skuOpportunitiesOutputSchema,
  recentNewsOutputSchema,
  conversationStartersOutputSchema,
  appendixOutputSchema
} from '../../prompts/validation';

// ============================================================================
// TYPES
// ============================================================================

export type StageId = 
  | 'foundation'
  | 'exec_summary'
  | 'financial_snapshot'
  | 'company_overview'
  | 'segment_analysis'
  | 'trends'
  | 'peer_benchmarking'
  | 'sku_opportunities'
  | 'recent_news'
  | 'conversation_starters'
  | 'appendix';

export interface StageConfig {
  id: StageId;
  title: string;
  dependencies: StageId[];
  promptBuilder: (input: any) => string;
  validationSchema: any;
  isAutoGenerated?: boolean; // For appendix
}

// ============================================================================
// DEPENDENCY MAP
// ============================================================================

export const STAGE_DEPENDENCIES: Record<StageId, StageId[]> = {
  // Phase 0 - Foundation (runs first, not shown in UI)
  'foundation': [],
  
  // Phase 1 - Core sections (parallel execution)
  'financial_snapshot': ['foundation'],
  'company_overview': ['foundation'],
  'recent_news': ['foundation'],
  
  // Phase 2 - Complex section
  'segment_analysis': ['foundation'],
  
  // Phase 3 - Dependent sections
  'trends': ['foundation'],
  'peer_benchmarking': ['foundation', 'financial_snapshot'],
  'sku_opportunities': ['foundation'],
  
  // Phase 4 - Synthesis
  'exec_summary': ['foundation', 'financial_snapshot', 'company_overview'],
  'conversation_starters': ['foundation'],
  
  // Phase 5 - Appendix (auto-generated)
  'appendix': ['foundation'],
};

// ============================================================================
// STAGE CONFIGURATIONS
// ============================================================================

export const STAGE_CONFIGS: Record<StageId, StageConfig> = {
  foundation: {
    id: 'foundation',
    title: 'Foundation Research',
    dependencies: [],
    promptBuilder: buildFoundationPrompt,
    validationSchema: foundationOutputSchema
  },
  exec_summary: {
    id: 'exec_summary',
    title: 'Executive Summary',
    dependencies: STAGE_DEPENDENCIES.exec_summary,
    promptBuilder: buildExecSummaryPrompt,
    validationSchema: execSummaryOutputSchema
  },
  financial_snapshot: {
    id: 'financial_snapshot',
    title: 'Financial Snapshot',
    dependencies: STAGE_DEPENDENCIES.financial_snapshot,
    promptBuilder: buildFinancialSnapshotPrompt,
    validationSchema: financialSnapshotOutputSchema
  },
  company_overview: {
    id: 'company_overview',
    title: 'Company Overview',
    dependencies: STAGE_DEPENDENCIES.company_overview,
    promptBuilder: buildCompanyOverviewPrompt,
    validationSchema: companyOverviewOutputSchema
  },
  segment_analysis: {
    id: 'segment_analysis',
    title: 'Segment Analysis',
    dependencies: STAGE_DEPENDENCIES.segment_analysis,
    promptBuilder: buildSegmentAnalysisPrompt,
    validationSchema: segmentAnalysisOutputSchema
  },
  trends: {
    id: 'trends',
    title: 'Market Trends',
    dependencies: STAGE_DEPENDENCIES.trends,
    promptBuilder: buildTrendsPrompt,
    validationSchema: trendsOutputSchema
  },
  peer_benchmarking: {
    id: 'peer_benchmarking',
    title: 'Peer Benchmarking',
    dependencies: STAGE_DEPENDENCIES.peer_benchmarking,
    promptBuilder: buildPeerBenchmarkingPrompt,
    validationSchema: peerBenchmarkingOutputSchema
  },
  sku_opportunities: {
    id: 'sku_opportunities',
    title: 'SKU Opportunities',
    dependencies: STAGE_DEPENDENCIES.sku_opportunities,
    promptBuilder: buildSkuOpportunitiesPrompt,
    validationSchema: skuOpportunitiesOutputSchema
  },
  recent_news: {
    id: 'recent_news',
    title: 'Recent News',
    dependencies: STAGE_DEPENDENCIES.recent_news,
    promptBuilder: buildRecentNewsPrompt,
    validationSchema: recentNewsOutputSchema
  },
  conversation_starters: {
    id: 'conversation_starters',
    title: 'Conversation Starters',
    dependencies: STAGE_DEPENDENCIES.conversation_starters,
    promptBuilder: buildConversationStartersPrompt,
    validationSchema: conversationStartersOutputSchema
  },
  appendix: {
    id: 'appendix',
    title: 'Appendix & Sources',
    dependencies: STAGE_DEPENDENCIES.appendix,
    promptBuilder: () => '', // Auto-generated
    validationSchema: appendixOutputSchema,
    isAutoGenerated: true
  }
};

// ============================================================================
// ORCHESTRATOR CLASS
// ============================================================================

export class ResearchOrchestrator {
  private prisma: PrismaClient;
  private claudeClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.claudeClient = getClaudeClient();
  }

  /**
   * Create a new research job with all sub-jobs
   */
  async createJob(input: {
    companyName: string;
    geography: string;
    industry?: string;
    focusAreas?: string[];
    userId: string;
  }) {
    const job = await this.prisma.researchJob.create({
      data: {
        companyName: input.companyName,
        geography: input.geography,
        industry: input.industry,
        focusAreas: input.focusAreas || [],
        status: 'pending',
        progress: 0,
        userId: input.userId,
        metadata: {
          focusAreas: input.focusAreas || [],
          sourceTracking: {
            baseSourceCount: 0,
            sectionSources: {},
            quoteSources: {}
          }
        }
      }
    });

    // Create sub-jobs for all 11 stages (foundation + 10 sections)
    const allStages: StageId[] = [
      'foundation',
      'financial_snapshot',
      'company_overview',
      'segment_analysis',
      'trends',
      'peer_benchmarking',
      'sku_opportunities',
      'recent_news',
      'exec_summary',
      'conversation_starters',
      'appendix'
    ];

    await Promise.all(
      allStages.map(stage =>
        this.prisma.researchSubJob.create({
          data: {
            researchId: job.id,
            stage,
            status: 'pending',
            dependencies: STAGE_DEPENDENCIES[stage]
          }
        })
      )
    );

    // Start execution in background
    this.executeJob(job.id).catch(console.error);

    return job;
  }

  /**
   * Execute the entire research job
   */
  async executeJob(jobId: string) {
    try {
      await this.updateJobStatus(jobId, 'running');

      // Execute stages in dependency order
      await this.executeNextPhase(jobId);

      // Mark as completed
      await this.updateJobStatus(jobId, 'completed');
    } catch (error) {
      console.error(`Job ${jobId} failed:`, error);
      await this.updateJobStatus(jobId, 'failed');
    }
  }

  /**
   * Execute the next phase of stages (dependency-aware)
   */
  private async executeNextPhase(jobId: string) {
    const runnable = await this.getNextRunnableStages(jobId);

    if (runnable.length === 0) {
      // Check if job is complete
      await this.checkJobCompletion(jobId);
      return;
    }

    // Execute all runnable stages in parallel
    await Promise.all(
      runnable.map(stage => this.executeStage(jobId, stage))
    );

    // After this phase completes, check for next phase
    await this.executeNextPhase(jobId);
  }

  /**
   * Get stages that can run now (dependencies met)
   */
  private async getNextRunnableStages(jobId: string): Promise<StageId[]> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return [];

    const completed = new Set(
      job.subJobs
        .filter(j => j.status === 'completed')
        .map(j => j.stage as StageId)
    );

    const running = new Set(
      job.subJobs
        .filter(j => j.status === 'running')
        .map(j => j.stage as StageId)
    );

    const pending = job.subJobs
      .filter(j => j.status === 'pending')
      .map(j => j.stage as StageId);

    const runnable: StageId[] = [];

    for (const stage of pending) {
      const deps = STAGE_DEPENDENCIES[stage] || [];
      const depsCompleted = deps.every(dep => completed.has(dep));
      const notRunning = !running.has(stage);

      if (depsCompleted && notRunning) {
        runnable.push(stage);
      }
    }

    return runnable;
  }

  /**
   * Execute a single stage
   */
  private async executeStage(jobId: string, stageId: StageId) {
    try {
      // Mark as running
      await this.updateSubJobStatus(jobId, stageId, 'running');
      await this.updateJobCurrentStage(jobId, stageId);

      const startTime = Date.now();

      // Handle appendix auto-generation
      if (stageId === 'appendix') {
        await this.executeAppendix(jobId);
        const duration = Date.now() - startTime;
        await this.completeSubJob(jobId, stageId, duration);
        return;
      }

      // Build prompt with context
      const prompt = await this.buildStagePrompt(jobId, stageId);

      // Execute with Claude
      const response = await this.claudeClient.execute(prompt);

      // Parse and validate
      const config = STAGE_CONFIGS[stageId];
      const output = this.claudeClient.validateAndParse(
        response,
        config.validationSchema
      );

      // Save output
      await this.saveStageOutput(jobId, stageId, output);

      const duration = Date.now() - startTime;
      await this.completeSubJob(jobId, stageId, duration);

    } catch (error) {
      console.error(`Stage ${stageId} failed:`, error);
      await this.handleStageFailure(jobId, stageId, error);
    }
  }

  /**
   * Build prompt with all required context
   */
  private async buildStagePrompt(jobId: string, stageId: StageId): Promise<string> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job) throw new Error('Job not found');

    const config = STAGE_CONFIGS[stageId];
    
    // Build input object with all required context
    const input: any = {
      companyName: job.companyName,
      geography: job.geography,
      foundation: job.foundation
    };

    // Add optional context based on dependencies
    if (job.financialSnapshot) input.section2 = job.financialSnapshot;
    if (job.companyOverview) input.section3 = job.companyOverview;
    if (job.segmentAnalysis) input.section4 = job.segmentAnalysis;
    if (job.trends) input.section5 = job.trends;
    if (job.peerBenchmarking) input.section6 = job.peerBenchmarking;
    if (job.skuOpportunities) input.section7 = job.skuOpportunities;
    if (job.recentNews) input.section8 = job.recentNews;

    return config.promptBuilder(input);
  }

  /**
   * Execute appendix (auto-generated)
   */
  private async executeAppendix(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job || !job.foundation) {
      throw new Error('Foundation not available for appendix generation');
    }

    const sections = {
      section1: job.execSummary,
      section2: job.financialSnapshot,
      section3: job.companyOverview,
      section4: job.segmentAnalysis,
      section5: job.trends,
      section6: job.peerBenchmarking,
      section7: job.skuOpportunities,
      section8: job.recentNews,
      section9: job.conversationStarters
    };

    const appendixOutput = generateAppendix({
      foundation: job.foundation as FoundationOutput,
      companyName: job.companyName,
      geography: job.geography,
      sections
    });

    await this.saveStageOutput(jobId, 'appendix', appendixOutput);
  }

  /**
   * Save stage output to database
   */
  private async saveStageOutput(jobId: string, stageId: StageId, output: any) {
    const fieldMap: Record<StageId, string> = {
      foundation: 'foundation',
      exec_summary: 'execSummary',
      financial_snapshot: 'financialSnapshot',
      company_overview: 'companyOverview',
      segment_analysis: 'segmentAnalysis',
      trends: 'trends',
      peer_benchmarking: 'peerBenchmarking',
      sku_opportunities: 'skuOpportunities',
      recent_news: 'recentNews',
      conversation_starters: 'conversationStarters',
      appendix: 'appendix'
    };

    const field = fieldMap[stageId];
    if (!field) throw new Error(`Unknown stage: ${stageId}`);

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: {
        [field]: output,
        overallConfidence: output.confidence?.level || 'MEDIUM'
      }
    });

    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        output,
        confidence: output.confidence?.level || 'MEDIUM',
        sourcesUsed: output.sources_used || []
      }
    });

    await this.updateOverallConfidence(jobId);
  }

  /**
   * Complete a sub-job
   */
  private async completeSubJob(jobId: string, stageId: StageId, duration: number) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        status: 'completed',
        completedAt: new Date(),
        duration
      }
    });

    await this.updateProgress(jobId);
  }

  /**
   * Handle stage failure with retry logic
   */
  private async handleStageFailure(jobId: string, stageId: StageId, error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    const subJob = await this.prisma.researchSubJob.findFirst({
      where: { researchId: jobId, stage: stageId }
    });

    if (!subJob) return;

    const attempts = subJob.attempts + 1;

    if (attempts < subJob.maxAttempts) {
      // Retry
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          attempts,
          lastError: errorMessage,
          status: 'pending'
        }
      });
    } else {
      // Max retries exceeded
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          status: 'failed',
          lastError: errorMessage
        }
      });
    }
  }

  /**
   * Update job status
   */
  private async updateJobStatus(jobId: string, status: string) {
    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { status }
    });
  }

  /**
   * Update current stage
   */
  private async updateJobCurrentStage(jobId: string, stage: StageId) {
    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { currentStage: stage }
    });
  }

  /**
   * Update sub-job status
   */
  private async updateSubJobStatus(jobId: string, stage: StageId, status: string) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage },
      data: { status }
    });
  }

  /**
   * Update progress
   */
  private async updateProgress(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    const total = 11; // foundation + 10 sections
    const completed = job.subJobs.filter(j => j.status === 'completed').length;
    const progress = completed / total;

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { progress }
    });
  }

  /**
   * Check if job is complete
   */
  private async checkJobCompletion(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    const allComplete = job.subJobs.every(j => 
      j.status === 'completed' || j.status === 'failed'
    );

    if (allComplete) {
      const anyFailed = job.subJobs.some(j => j.status === 'failed');
      await this.updateJobStatus(jobId, anyFailed ? 'failed' : 'completed');
    }
  }

  /**
   * Recompute overall confidence score/label from completed sub-jobs
   */
  private async updateOverallConfidence(jobId: string) {
    const subJobs = await this.prisma.researchSubJob.findMany({
      where: { researchId: jobId, status: 'completed' },
      select: { confidence: true }
    });

    const scores = subJobs
      .map((s) => this.confidenceToScore(s.confidence))
      .filter((n): n is number => n !== null && !Number.isNaN(n));

    if (!scores.length) {
      await this.prisma.researchJob.update({
        where: { id: jobId },
        data: {
          overallConfidence: null,
          overallConfidenceScore: null
        }
      });
      return;
    }

    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    const label = this.scoreToLabel(avg);

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: {
        overallConfidence: label,
        overallConfidenceScore: avg
      }
    });
  }

  private confidenceToScore(confidence?: string | null): number | null {
    if (!confidence) return null;
    const upper = confidence.toUpperCase();
    if (upper === 'HIGH') return 0.9;
    if (upper === 'MEDIUM') return 0.6;
    if (upper === 'LOW') return 0.3;
    return null;
  }

  private scoreToLabel(score: number): string {
    if (score >= 0.75) return 'HIGH';
    if (score >= 0.5) return 'MEDIUM';
    return 'LOW';
  }
}
