/**
 * Job Orchestrator
 * Manages research job execution with dependency resolution and parallel processing
 */

import { PrismaClient } from '@prisma/client';
import { getClaudeClient } from './claude-client.js';
import type { FoundationOutput } from '../types/prompts.js';
import type { ClaudeResponse } from './claude-client.js';

// Import prompt builders (these will be renamed section files)
import { buildFoundationPrompt } from '../../prompts/foundation-prompt.js';
import { buildExecSummaryPrompt } from '../../prompts/exec-summary.js';
import { buildFinancialSnapshotPrompt } from '../../prompts/financial-snapshot.js';
import { buildCompanyOverviewPrompt } from '../../prompts/company-overview.js';
import { buildSegmentAnalysisPrompt } from '../../prompts/segment-analysis.js';
import { buildTrendsPrompt } from '../../prompts/trends.js';
import { buildPeerBenchmarkingPrompt } from '../../prompts/peer-benchmarking.js';
import { buildSkuOpportunitiesPrompt } from '../../prompts/sku-opportunities.js';
import { buildRecentNewsPrompt } from '../../prompts/recent-news.js';
import { buildConversationStartersPrompt } from '../../prompts/conversation-starters.js';
import { generateAppendix } from '../../prompts/appendix.js';

// Import validation schemas
import {
  foundationOutputSchema,
  execSummaryOutputSchema,
  financialSnapshotOutputSchema,
  companyOverviewOutputSchema,
  segmentAnalysisOutputSchema,
  trendsOutputSchema,
  peerBenchmarkingOutputSchema,
  skuOpportunitiesOutputSchema,
  recentNewsOutputSchema,
  conversationStartersOutputSchema,
  appendixOutputSchema
} from '../../prompts/validation.js';

// ============================================================================
// TYPES
// ============================================================================

export type StageId = 
  | 'foundation'
  | 'exec_summary'
  | 'financial_snapshot'
  | 'company_overview'
  | 'segment_analysis'
  | 'trends'
  | 'peer_benchmarking'
  | 'sku_opportunities'
  | 'recent_news'
  | 'conversation_starters'
  | 'appendix';

export interface StageConfig {
  id: StageId;
  title: string;
  dependencies: StageId[];
  promptBuilder: (input: any) => string;
  validationSchema: any;
  isAutoGenerated?: boolean; // For appendix
}

// ============================================================================
// DEPENDENCY MAP
// ============================================================================

export const STAGE_DEPENDENCIES: Record<StageId, StageId[]> = {
  // Phase 0 - Foundation (runs first, not shown in UI)
  'foundation': [],
  
  // Phase 1 - Core sections (parallel execution)
  'financial_snapshot': ['foundation'],
  'company_overview': ['foundation'],
  'recent_news': ['foundation'],
  
  // Phase 2 - Complex section
  'segment_analysis': ['foundation'],
  
  // Phase 3 - Dependent sections
  'trends': ['foundation'],
  'peer_benchmarking': ['foundation', 'financial_snapshot'],
  'sku_opportunities': ['foundation'],
  
  // Phase 4 - Synthesis
  'exec_summary': ['foundation', 'financial_snapshot', 'company_overview'],
  'conversation_starters': ['foundation'],
  
  // Phase 5 - Appendix (auto-generated)
  'appendix': ['foundation'],
};

// ============================================================================
// STAGE CONFIGURATIONS
// ============================================================================

export const STAGE_CONFIGS: Record<StageId, StageConfig> = {
  foundation: {
    id: 'foundation',
    title: 'Foundation Research',
    dependencies: [],
    promptBuilder: buildFoundationPrompt,
    validationSchema: foundationOutputSchema
  },
  exec_summary: {
    id: 'exec_summary',
    title: 'Executive Summary',
    dependencies: STAGE_DEPENDENCIES.exec_summary,
    promptBuilder: buildExecSummaryPrompt,
    validationSchema: execSummaryOutputSchema
  },
  financial_snapshot: {
    id: 'financial_snapshot',
    title: 'Financial Snapshot',
    dependencies: STAGE_DEPENDENCIES.financial_snapshot,
    promptBuilder: buildFinancialSnapshotPrompt,
    validationSchema: financialSnapshotOutputSchema
  },
  company_overview: {
    id: 'company_overview',
    title: 'Company Overview',
    dependencies: STAGE_DEPENDENCIES.company_overview,
    promptBuilder: buildCompanyOverviewPrompt,
    validationSchema: companyOverviewOutputSchema
  },
  segment_analysis: {
    id: 'segment_analysis',
    title: 'Segment Analysis',
    dependencies: STAGE_DEPENDENCIES.segment_analysis,
    promptBuilder: buildSegmentAnalysisPrompt,
    validationSchema: segmentAnalysisOutputSchema
  },
  trends: {
    id: 'trends',
    title: 'Market Trends',
    dependencies: STAGE_DEPENDENCIES.trends,
    promptBuilder: buildTrendsPrompt,
    validationSchema: trendsOutputSchema
  },
  peer_benchmarking: {
    id: 'peer_benchmarking',
    title: 'Peer Benchmarking',
    dependencies: STAGE_DEPENDENCIES.peer_benchmarking,
    promptBuilder: buildPeerBenchmarkingPrompt,
    validationSchema: peerBenchmarkingOutputSchema
  },
  sku_opportunities: {
    id: 'sku_opportunities',
    title: 'SKU Opportunities',
    dependencies: STAGE_DEPENDENCIES.sku_opportunities,
    promptBuilder: buildSkuOpportunitiesPrompt,
    validationSchema: skuOpportunitiesOutputSchema
  },
  recent_news: {
    id: 'recent_news',
    title: 'Recent News',
    dependencies: STAGE_DEPENDENCIES.recent_news,
    promptBuilder: buildRecentNewsPrompt,
    validationSchema: recentNewsOutputSchema
  },
  conversation_starters: {
    id: 'conversation_starters',
    title: 'Conversation Starters',
    dependencies: STAGE_DEPENDENCIES.conversation_starters,
    promptBuilder: buildConversationStartersPrompt,
    validationSchema: conversationStartersOutputSchema
  },
  appendix: {
    id: 'appendix',
    title: 'Appendix & Sources',
    dependencies: STAGE_DEPENDENCIES.appendix,
    promptBuilder: () => '', // Auto-generated
    validationSchema: appendixOutputSchema,
    isAutoGenerated: true
  }
};

// ============================================================================
// ORCHESTRATOR CLASS
// ============================================================================

export class ResearchOrchestrator {
  private prisma: PrismaClient;
  private claudeClient;
  private queueLockId = BigInt(937451); // arbitrary global lock id
  private queueLoopRunning = false;
  private queueWatchdogStarted = false;
  private modelPricing: Record<string, { prompt: number; completion: number }> = {
    // USD per 1M tokens (set to 0 by default; adjust if pricing changes)
    'claude-sonnet-4-5': { prompt: 3, completion: 15 },
    default: { prompt: 0, completion: 0 }
  };

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.claudeClient = getClaudeClient();
    this.startQueueWatchdog();
  }

  /**
   * Create a new research job with all sub-jobs
   */
  async createJob(input: {
    companyName: string;
    geography: string;
    industry?: string;
    focusAreas?: string[];
    userId: string;
  }) {
    const job = await this.prisma.researchJob.create({
      data: {
        companyName: input.companyName,
        geography: input.geography,
        industry: input.industry,
        focusAreas: input.focusAreas || [],
        status: 'queued',
        queuedAt: new Date(),
        progress: 0,
        userId: input.userId,
        metadata: {
          focusAreas: input.focusAreas || [],
          sourceTracking: {
            baseSourceCount: 0,
            sectionSources: {},
            quoteSources: {}
          }
        }
      }
    });

    // Create sub-jobs for all 11 stages (foundation + 10 sections)
    const allStages: StageId[] = [
      'foundation',
      'financial_snapshot',
      'company_overview',
      'segment_analysis',
      'trends',
      'peer_benchmarking',
      'sku_opportunities',
      'recent_news',
      'exec_summary',
      'conversation_starters',
      'appendix'
    ];

    await Promise.all(
      allStages.map(stage =>
        this.prisma.researchSubJob.create({
          data: {
            researchId: job.id,
            stage,
            status: 'pending',
            dependencies: STAGE_DEPENDENCIES[stage]
          }
        })
      )
    );

    // Kick off queue processor in background (force restart to avoid stale flag)
    this.processQueue(true).catch(console.error);

    return job;
  }

  /**
   * Main queue processor - ensures only one job executes at a time using pg advisory lock
   */
  async processQueue(forceRestart = false) {
    if (this.queueLoopRunning && !forceRestart) return;
    if (forceRestart) {
      this.queueLoopRunning = false;
    }
    this.queueLoopRunning = true;

    try {
      while (true) {
        let lockHeld = false;
        try {
          const lockAcquired = await this.tryAcquireLock();
          if (!lockAcquired) {
            await this.delay(750);
            continue;
          }
          lockHeld = true;

          // If a job is already running, back off and retry later
          const runningCount = await this.prisma.researchJob.count({
            where: { status: 'running' }
          });
          if (runningCount > 0) {
            console.log('[queue] Detected running job, delaying promotion');
            await this.releaseLock();
            lockHeld = false;
            await this.delay(750);
            continue;
          }

          const jobToRun = await this.prisma.researchJob.findFirst({
            where: { status: 'queued' },
            orderBy: { queuedAt: 'asc' },
            select: { id: true }
          });

          if (!jobToRun) {
            // Nothing to do; release lock and exit loop
            await this.releaseLock();
            lockHeld = false;
            break;
          }

          console.log('[queue] Promoting job to running:', jobToRun.id);
          await this.prisma.researchJob.update({
            where: { id: jobToRun.id },
            data: {
              status: 'running',
              startedAt: new Date()
            }
          });

          await this.executeJob(jobToRun.id);
        } finally {
          if (lockHeld) {
            await this.releaseLock();
          }
        }

        // Small gap before next iteration to avoid tight loop
        await this.delay(200);
      }
    } catch (error) {
      console.error('Queue processor error:', error);
    } finally {
      this.queueLoopRunning = false;
    }
  }

  /**
   * Execute the entire research job
   */
  async executeJob(jobId: string) {
    try {
      const existing = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true }
      });
      if (!existing || existing.status === 'cancelled') {
        return;
      }

      await this.updateJobStatus(jobId, 'running');

      // Execute stages in dependency order
      await this.executeNextPhase(jobId);

      // Finalize status based on sub-job results
      const subJobs = await this.prisma.researchSubJob.findMany({
        where: { researchId: jobId },
        select: { status: true }
      });
      const anyFailed = subJobs.some(s => s.status === 'failed');
      const allTerminal = subJobs.every(s => ['completed', 'failed', 'cancelled'].includes(s.status));
      if (anyFailed) {
        await this.updateJobStatus(jobId, 'failed');
      } else if (allTerminal) {
        await this.updateJobStatus(jobId, 'completed');
      }
    } catch (error) {
      console.error(`Job ${jobId} failed:`, error);
      await this.updateJobStatus(jobId, 'failed');
    } finally {
      // Ensure the queue loop continues after this job finishes
      this.processQueue().catch(console.error);
    }
  }

  /**
   * Execute the next phase of stages (dependency-aware)
   */
  private async executeNextPhase(jobId: string) {
    const cancelled = await this.isJobCancelled(jobId);
    if (cancelled) return;

    const runnable = await this.getNextRunnableStages(jobId);

    if (runnable.length === 0) {
      // Check if job is complete
      await this.checkJobCompletion(jobId);
      return;
    }

    // Execute runnable stages sequentially to ensure only one Claude call at a time
    for (const stage of runnable) {
      const cancelledMidway = await this.isJobCancelled(jobId);
      if (cancelledMidway) return;
      await this.executeStage(jobId, stage);
    }

    // After this phase completes, check for next phase
    await this.executeNextPhase(jobId);
  }

  /**
   * Get stages that can run now (dependencies met)
   */
  private async getNextRunnableStages(jobId: string): Promise<StageId[]> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job || job.status === 'cancelled') return [];

    const completed = new Set(
      job.subJobs
        .filter(j => j.status === 'completed')
        .map(j => j.stage as StageId)
    );

    const running = new Set(
      job.subJobs
        .filter(j => j.status === 'running')
        .map(j => j.stage as StageId)
    );

    const pending = job.subJobs
      .filter(j => j.status === 'pending')
      .map(j => j.stage as StageId);

    const runnable: StageId[] = [];

    for (const stage of pending) {
      const deps = STAGE_DEPENDENCIES[stage] || [];
      const depsCompleted = deps.every(dep => completed.has(dep));
      const notRunning = !running.has(stage);

      if (depsCompleted && notRunning) {
        runnable.push(stage);
      }
    }

    return runnable;
  }

  /**
   * Execute a single stage
   */
  private async executeStage(jobId: string, stageId: StageId) {
    let response: ClaudeResponse | null = null;
    try {
      const job = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true }
      });
      if (!job || job.status === 'cancelled') {
        return;
      }
      // Mark as running
      await this.updateSubJobStatus(jobId, stageId, 'running');
      await this.updateJobCurrentStage(jobId, stageId);

      const startTime = Date.now();

      // Handle appendix auto-generation
      if (stageId === 'appendix') {
        await this.executeAppendix(jobId);
        const duration = Date.now() - startTime;
        await this.completeSubJob(jobId, stageId, duration);
        return;
      }

      // Build prompt with context
      const prompt = await this.buildStagePrompt(jobId, stageId);

      // Execute with Claude
      response = await this.claudeClient.execute(prompt);

      // Parse and validate
      const config = STAGE_CONFIGS[stageId];
      let output = this.claudeClient.validateAndParse(
        response,
        config.validationSchema
      );

      // Sanitize common issues before content check/save
      if (stageId === 'exec_summary') {
        output = this.sanitizeExecSummary(output);
      } else if (stageId === 'segment_analysis') {
        output = this.sanitizeSegmentAnalysis(output);
      }

      // Guard against empty/invalid content that passed validation
      this.ensureStageHasContent(stageId, output);

      await this.recordTokenUsage(jobId, stageId, response!);

      // Save output
      await this.saveStageOutput(jobId, stageId, output);

      const duration = Date.now() - startTime;
      await this.completeSubJob(jobId, stageId, duration);

    } catch (error) {
      console.error(`Stage ${stageId} failed:`, error);
      const rawContent = response?.content;
      await this.handleStageFailure(jobId, stageId, error, rawContent);

       // If this stage is now marked failed (exceeded retries), fail the whole job
       const sub = await this.prisma.researchSubJob.findFirst({
         where: { researchId: jobId, stage: stageId },
         select: { status: true }
       });
       if (sub?.status === 'failed') {
         await this.updateJobStatus(jobId, 'failed');
         throw error;
       }
    }
  }

  /**
   * Build prompt with all required context
   */
  private async buildStagePrompt(jobId: string, stageId: StageId): Promise<string> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job) throw new Error('Job not found');

    const config = STAGE_CONFIGS[stageId];
    
    // Build input object with all required context
    const input: any = {
      companyName: job.companyName,
      geography: job.geography,
      foundation: job.foundation
    };

    // Add optional context based on dependencies
    if (job.financialSnapshot) input.section2 = job.financialSnapshot;
    if (job.companyOverview) input.section3 = job.companyOverview;
    if (job.segmentAnalysis) input.section4 = job.segmentAnalysis;
    if (job.trends) input.section5 = job.trends;
    if (job.peerBenchmarking) input.section6 = job.peerBenchmarking;
    if (job.skuOpportunities) input.section7 = job.skuOpportunities;
    if (job.recentNews) input.section8 = job.recentNews;

    return config.promptBuilder(input);
  }

  /**
   * Execute appendix (auto-generated)
   */
  private async executeAppendix(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job || !job.foundation) {
      throw new Error('Foundation not available for appendix generation');
    }

    const sections: any = {
      section1: job.execSummary,
      section2: job.financialSnapshot,
      section3: job.companyOverview,
      section4: job.segmentAnalysis,
      section5: job.trends,
      section6: job.peerBenchmarking,
      section7: job.skuOpportunities,
      section8: job.recentNews,
      section9: job.conversationStarters
    };

    const appendixOutput = generateAppendix({
      foundation: job.foundation as unknown as FoundationOutput,
      companyName: job.companyName,
      geography: job.geography,
      sections
    });

    await this.saveStageOutput(jobId, 'appendix', appendixOutput);
  }

  /**
   * Save stage output to database
   */
  private async saveStageOutput(jobId: string, stageId: StageId, output: any) {
    const fieldMap: Record<StageId, string> = {
      foundation: 'foundation',
      exec_summary: 'execSummary',
      financial_snapshot: 'financialSnapshot',
      company_overview: 'companyOverview',
      segment_analysis: 'segmentAnalysis',
      trends: 'trends',
      peer_benchmarking: 'peerBenchmarking',
      sku_opportunities: 'skuOpportunities',
      recent_news: 'recentNews',
      conversation_starters: 'conversationStarters',
      appendix: 'appendix'
    };

    const field = fieldMap[stageId];
    if (!field) throw new Error(`Unknown stage: ${stageId}`);

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: {
        [field]: output,
        overallConfidence: output.confidence?.level || 'MEDIUM'
      }
    });

    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        output,
        confidence: output.confidence?.level || 'MEDIUM',
        sourcesUsed: output.sources_used || []
      }
    });

    await this.updateOverallConfidence(jobId);
  }

  /**
   * Complete a sub-job
   */
  private async completeSubJob(jobId: string, stageId: StageId, duration: number) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        status: 'completed',
        completedAt: new Date(),
        duration
      }
    });

    await this.updateProgress(jobId);
  }

  /**
   * Handle stage failure with retry logic
   */
  private async handleStageFailure(jobId: string, stageId: StageId, error: unknown, rawContent?: string) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    const subJob = await this.prisma.researchSubJob.findFirst({
      where: { researchId: jobId, stage: stageId }
    });

    if (!subJob) return;

    const attempts = subJob.attempts + 1;

    if (attempts < subJob.maxAttempts) {
      // Back off briefly on rate limit errors
      if (this.isRateLimitError(errorMessage)) {
        await this.delay(2000);
      }
      // Retry
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          attempts,
          lastError: errorMessage,
          output: (rawContent ? { rawContent, error: errorMessage } : subJob.output) as any,
          status: 'pending'
        }
      });
    } else {
      // Max retries exceeded
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          status: 'failed',
          lastError: errorMessage,
          output: (rawContent ? { rawContent, error: errorMessage } : subJob.output) as any
        }
      });
    }
  }

  /**
   * Update job status
   */
  private async updateJobStatus(jobId: string, status: string) {
    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { status }
    });

    if (status === 'cancelled') {
      // Mark running/pending subjobs as cancelled too
      await this.prisma.researchSubJob.updateMany({
        where: { researchId: jobId, status: { in: ['pending', 'running'] } },
        data: { status: 'cancelled', completedAt: new Date() }
      });
    }
  }

  /**
   * Update current stage
   */
  private async updateJobCurrentStage(jobId: string, stage: StageId) {
    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { currentStage: stage }
    });
  }

  /**
   * Update sub-job status
   */
  private async updateSubJobStatus(jobId: string, stage: StageId, status: string) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage },
      data: { status }
    });
  }

  /**
   * Update progress
   */
  private async updateProgress(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    const total = 11; // foundation + 10 sections
    const completed = job.subJobs.filter(j => j.status === 'completed').length;
    const progress = completed / total;

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: { progress }
    });
  }

  /**
   * Check if job is complete
   */
  private async checkJobCompletion(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    if (job.status === 'cancelled') {
      return;
    }

    const allComplete = job.subJobs.every(j => 
      j.status === 'completed' || j.status === 'failed' || j.status === 'cancelled'
    );

    if (allComplete) {
      const anyFailed = job.subJobs.some(j => j.status === 'failed');
      await this.updateJobStatus(jobId, anyFailed ? 'failed' : 'completed');
    }
  }

  /**
   * Recompute overall confidence score/label from completed sub-jobs
   */
  private async updateOverallConfidence(jobId: string) {
    const subJobs = await this.prisma.researchSubJob.findMany({
      where: { researchId: jobId, status: 'completed' },
      select: { confidence: true }
    });

    const scores = subJobs
      .map((s) => this.confidenceToScore(s.confidence))
      .filter((n): n is number => n !== null && !Number.isNaN(n));

    if (!scores.length) {
      await this.prisma.researchJob.update({
        where: { id: jobId },
        data: {
          overallConfidence: null,
          overallConfidenceScore: null
        }
      });
      return;
    }

    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    const label = this.scoreToLabel(avg);

    await this.prisma.researchJob.update({
      where: { id: jobId },
      data: {
        overallConfidence: label,
        overallConfidenceScore: avg
      }
    });
  }

  private confidenceToScore(confidence?: string | null): number | null {
    if (!confidence) return null;
    const upper = confidence.toUpperCase();
    if (upper === 'HIGH') return 0.9;
    if (upper === 'MEDIUM') return 0.6;
    if (upper === 'LOW') return 0.3;
    return null;
  }

  private scoreToLabel(score: number): string {
    if (score >= 0.75) return 'HIGH';
    if (score >= 0.5) return 'MEDIUM';
    return 'LOW';
  }

  private sanitizeExecSummary(output: any) {
    const bullets = Array.isArray(output?.bullet_points)
      ? output.bullet_points
          .map((b: any) => ({
            ...b,
            bullet: typeof b?.bullet === 'string' ? b.bullet.trim() : String(b?.bullet ?? '').trim()
          }))
          .filter((b: any) => b.bullet.length > 0)
      : [];

    return {
      ...output,
      bullet_points: bullets
    };
  }

  private sanitizeSegmentAnalysis(output: any) {
    const rawSources = Array.isArray(output?.sources_used) ? output.sources_used : [];
    const cleanedSources = Array.from(
      new Set(
        rawSources
          .map((s: any) => (typeof s === 'string' ? s.trim() : String(s ?? '').trim()))
          .filter((s: string) => /^S\d+$/.test(s))
      )
    );

    const segments = Array.isArray(output?.segments) ? output.segments.map((seg: any) => {
      const comp = Array.isArray(seg?.competitive_landscape?.competitors)
        ? seg.competitive_landscape.competitors.slice(0, 5) // cap to max 5 to avoid validation failure
        : [];
      return {
        ...seg,
        competitive_landscape: {
          ...(seg?.competitive_landscape || {}),
          competitors: comp
        }
      };
    }) : [];

    return {
      ...output,
      sources_used: cleanedSources,
      segments
    };
  }

  /**
   * Ensure a section output has meaningful content; throw if empty to force retry/failure
   */
  private ensureStageHasContent(stageId: StageId, output: any) {
    if (!output || typeof output !== 'object') {
      throw new Error(`Stage ${stageId} returned empty output`);
    }

    if (stageId === 'exec_summary') {
      const bullets = Array.isArray(output.bullet_points) ? output.bullet_points.length : 0;
      if (bullets < 3) {
        throw new Error('Executive Summary missing bullet_points');
      }
    }

    if (stageId === 'segment_analysis') {
      const segments = Array.isArray(output.segments) ? output.segments.length : 0;
      if (!output.overview && segments === 0) {
        throw new Error('Segment Analysis missing overview or segments');
      }
    }
  }

  /**
   * Track token usage and estimated cost for each call
   */
  private async recordTokenUsage(jobId: string, stageId: StageId, response: ClaudeResponse) {
    const inputTokens = response.usage?.inputTokens || 0;
    const outputTokens = response.usage?.outputTokens || 0;
    const model = typeof this.claudeClient.getModelName === 'function'
      ? this.claudeClient.getModelName()
      : process.env.CLAUDE_MODEL || 'claude-sonnet-4-5';

    const pricing = this.modelPricing[model] || this.modelPricing.default;
    const costUsd = ((inputTokens * pricing.prompt) + (outputTokens * pricing.completion)) / 1_000_000;

    await this.prisma.$transaction([
      this.prisma.researchSubJob.updateMany({
        where: { researchId: jobId, stage: stageId },
        data: {
          promptTokens: { increment: inputTokens },
          completionTokens: { increment: outputTokens },
          costUsd: { increment: costUsd }
        }
      }),
      this.prisma.researchJob.update({
        where: { id: jobId },
        data: {
          promptTokens: { increment: inputTokens },
          completionTokens: { increment: outputTokens },
          costUsd: { increment: costUsd }
        }
      })
    ]);
  }

  /**
   * Compute queue position for a job (running job counts as position 0)
   */
  async getQueuePosition(jobId: string): Promise<number> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { status: true, queuedAt: true, createdAt: true }
    });
    if (!job) return 0;

    const anchor = job.queuedAt || job.createdAt;
    const queuedAhead = await this.prisma.researchJob.count({
      where: {
        status: 'queued',
        queuedAt: { lt: anchor }
      }
    });
    const runningCount = await this.prisma.researchJob.count({
      where: { status: 'running' }
    });

    if (job.status === 'running') {
      return 0;
    }

    return queuedAhead + runningCount + 1;
  }

  // ============================================================================
  // Queue helpers
  // ============================================================================

  private async tryAcquireLock(): Promise<boolean> {
    const result = await this.prisma.$queryRaw<{ locked: boolean }[]>`
      SELECT pg_try_advisory_lock(${this.queueLockId}) AS locked
    `;
    return Boolean(result?.[0]?.locked);
  }

  private async releaseLock() {
    await this.prisma.$queryRaw`
      SELECT pg_advisory_unlock(${this.queueLockId})
    `;
  }

  private async delay(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  private async isJobCancelled(jobId: string): Promise<boolean> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { status: true }
    });
    return job?.status === 'cancelled';
  }

  private isRateLimitError(message: string): boolean {
    return message.toLowerCase().includes('rate limit') || message.includes('429');
  }

  /**
   * Periodic watchdog to kick the queue if it ever stalls
   */
  private startQueueWatchdog() {
    if (this.queueWatchdogStarted) return;
    this.queueWatchdogStarted = true;

    setInterval(async () => {
      try {
        if (this.queueLoopRunning) return;
        const queuedCount = await this.prisma.researchJob.count({
          where: { status: 'queued' }
        });
        if (queuedCount > 0) {
          this.processQueue(true).catch(console.error);
        }
      } catch (err) {
        console.error('Queue watchdog error:', err);
      }
    }, 10000); // every 10s
  }
}

// Singleton accessor so queue processor is shared
let orchestratorSingleton: ResearchOrchestrator | null = null;
export function getResearchOrchestrator(prisma: PrismaClient): ResearchOrchestrator {
  if (!orchestratorSingleton) {
    orchestratorSingleton = new ResearchOrchestrator(prisma);
  }
  return orchestratorSingleton;
}
