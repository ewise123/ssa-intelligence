/**
 * Job Orchestrator
 * Manages research job execution with dependency resolution and parallel processing
 */

import { PrismaClient, Prisma } from '@prisma/client';
import { getClaudeClient } from './claude-client.js';
import type { FoundationOutput } from '../types/prompts.js';
import type { ClaudeClient, ClaudeResponse } from './claude-client.js';

// Import prompt builders (these will be renamed section files)
import { buildFoundationPrompt } from '../../prompts/foundation-prompt.js';
import { buildExecSummaryPrompt } from '../../prompts/exec-summary.js';
import { buildFinancialSnapshotPrompt } from '../../prompts/financial-snapshot.js';
import { buildCompanyOverviewPrompt } from '../../prompts/company-overview.js';
import { buildSegmentAnalysisPrompt } from '../../prompts/segment-analysis.js';
import { buildTrendsPrompt } from '../../prompts/trends.js';
import { buildPeerBenchmarkingPrompt } from '../../prompts/peer-benchmarking.js';
import { buildSkuOpportunitiesPrompt } from '../../prompts/sku-opportunities.js';
import { buildRecentNewsPrompt } from '../../prompts/recent-news.js';
import { buildConversationStartersPrompt } from '../../prompts/conversation-starters.js';
import { buildInvestmentStrategyPrompt } from '../../prompts/investment-strategy.js';
import { buildPortfolioSnapshotPrompt } from '../../prompts/portfolio-snapshot.js';
import { buildDealActivityPrompt } from '../../prompts/deal-activity.js';
import { buildDealTeamPrompt } from '../../prompts/deal-team.js';
import { buildPortfolioMaturityPrompt } from '../../prompts/portfolio-maturity.js';
import { buildLeadershipAndGovernancePrompt } from '../../prompts/leadership-and-governance.js';
import { buildStrategicPrioritiesPrompt } from '../../prompts/strategic-priorities.js';
import { buildOperatingCapabilitiesPrompt } from '../../prompts/operating-capabilities.js';
import { generateAppendix } from '../../prompts/appendix.js';
import { generateThumbnailForJob } from './thumbnail.js';
import { getReportBlueprint } from './report-blueprints.js';
import { collectBlockedStages } from './dependency-utils.js';
import { computeFinalStatus, computeOverallConfidence, computeTerminalProgress } from './orchestrator-utils.js';

// Import validation schemas
import {
  foundationOutputSchema,
  execSummaryOutputSchema,
  financialSnapshotOutputSchema,
  companyOverviewOutputSchema,
  segmentAnalysisOutputSchema,
  trendsOutputSchema,
  peerBenchmarkingOutputSchema,
  skuOpportunitiesOutputSchema,
  recentNewsOutputSchema,
  conversationStartersOutputSchema,
  appendixOutputSchema,
  investmentStrategyOutputSchema,
  portfolioSnapshotOutputSchema,
  dealActivityOutputSchema,
  dealTeamOutputSchema,
  portfolioMaturityOutputSchema,
  leadershipAndGovernanceOutputSchema,
  strategicPrioritiesOutputSchema,
  operatingCapabilitiesOutputSchema,
  getValidationSchema,
  type ReportTypeId
} from '../../prompts/validation.js';

// ============================================================================
// TYPES
// ============================================================================

export type StageId = 
  | 'foundation'
  | 'exec_summary'
  | 'financial_snapshot'
  | 'company_overview'
  | 'investment_strategy'
  | 'portfolio_snapshot'
  | 'deal_activity'
  | 'deal_team'
  | 'portfolio_maturity'
  | 'leadership_and_governance'
  | 'strategic_priorities'
  | 'operating_capabilities'
  | 'segment_analysis'
  | 'trends'
  | 'peer_benchmarking'
  | 'sku_opportunities'
  | 'recent_news'
  | 'conversation_starters'
  | 'appendix';

export interface StageConfig {
  id: StageId;
  title: string;
  dependencies: StageId[];
  promptBuilder: (input: any) => string;
  validationSchema: any;
  isAutoGenerated?: boolean; // For appendix
}

export const STAGE_OUTPUT_FIELDS: Record<StageId, string | undefined> = {
  foundation: 'foundation',
  exec_summary: 'execSummary',
  financial_snapshot: 'financialSnapshot',
  company_overview: 'companyOverview',
  investment_strategy: undefined,
  portfolio_snapshot: undefined,
  deal_activity: undefined,
  deal_team: undefined,
  portfolio_maturity: undefined,
  leadership_and_governance: undefined,
  strategic_priorities: undefined,
  operating_capabilities: undefined,
  segment_analysis: 'segmentAnalysis',
  trends: 'trends',
  peer_benchmarking: 'peerBenchmarking',
  sku_opportunities: 'skuOpportunities',
  recent_news: 'recentNews',
  conversation_starters: 'conversationStarters',
  appendix: 'appendix'
};

// ============================================================================
// DEPENDENCY MAP
// ============================================================================

export const STAGE_DEPENDENCIES: Record<StageId, StageId[]> = {
  // Phase 0 - Foundation (runs first, not shown in UI)
  'foundation': [],
  
  // Phase 1 - Core sections (parallel execution)
  'financial_snapshot': ['foundation'],
  'company_overview': ['foundation'],
  'investment_strategy': ['foundation'],
  'portfolio_snapshot': ['foundation'],
  'deal_activity': ['foundation'],
  'leadership_and_governance': ['foundation'],
  'strategic_priorities': ['foundation'],
  'operating_capabilities': ['foundation'],
  'recent_news': ['foundation'],
  
  // Phase 2 - Complex section
  'segment_analysis': ['foundation'],
  
  // Phase 3 - Dependent sections
  'trends': ['foundation'],
  'peer_benchmarking': ['foundation', 'financial_snapshot'],
  'sku_opportunities': ['foundation'],
  'portfolio_maturity': ['foundation'],
  'deal_team': ['foundation'],
  
  // Phase 4 - Synthesis
  'exec_summary': ['foundation', 'financial_snapshot', 'company_overview'],
  'conversation_starters': ['foundation'],
  
  // Phase 5 - Appendix (auto-generated)
  'appendix': ['foundation'],
};

const USER_SELECTABLE_STAGES: StageId[] = [
  'exec_summary',
  'financial_snapshot',
  'company_overview',
  'investment_strategy',
  'portfolio_snapshot',
  'deal_activity',
  'leadership_and_governance',
  'strategic_priorities',
  'operating_capabilities',
  'segment_analysis',
  'trends',
  'peer_benchmarking',
  'sku_opportunities',
  'recent_news',
  'portfolio_maturity',
  'deal_team',
  'conversation_starters',
  'appendix'
];

const DEFAULT_STAGE_ORDER: StageId[] = [
  'foundation',
  'financial_snapshot',
  'company_overview',
  'investment_strategy',
  'portfolio_snapshot',
  'deal_activity',
  'leadership_and_governance',
  'strategic_priorities',
  'operating_capabilities',
  'segment_analysis',
  'trends',
  'peer_benchmarking',
  'sku_opportunities',
  'recent_news',
  'portfolio_maturity',
  'deal_team',
  'exec_summary',
  'conversation_starters',
  'appendix'
];

// ============================================================================
// STAGE CONFIGURATIONS
// ============================================================================

export const STAGE_CONFIGS: Record<StageId, StageConfig> = {
  foundation: {
    id: 'foundation',
    title: 'Foundation Research',
    dependencies: [],
    promptBuilder: buildFoundationPrompt,
    validationSchema: foundationOutputSchema
  },
  exec_summary: {
    id: 'exec_summary',
    title: 'Executive Summary',
    dependencies: STAGE_DEPENDENCIES.exec_summary,
    promptBuilder: buildExecSummaryPrompt,
    validationSchema: execSummaryOutputSchema
  },
  financial_snapshot: {
    id: 'financial_snapshot',
    title: 'Financial Snapshot',
    dependencies: STAGE_DEPENDENCIES.financial_snapshot,
    promptBuilder: buildFinancialSnapshotPrompt,
    validationSchema: financialSnapshotOutputSchema
  },
  company_overview: {
    id: 'company_overview',
    title: 'Company Overview',
    dependencies: STAGE_DEPENDENCIES.company_overview,
    promptBuilder: buildCompanyOverviewPrompt,
    validationSchema: companyOverviewOutputSchema
  },
  investment_strategy: {
    id: 'investment_strategy',
    title: 'Investment Strategy and Focus',
    dependencies: STAGE_DEPENDENCIES.investment_strategy,
    promptBuilder: buildInvestmentStrategyPrompt,
    validationSchema: investmentStrategyOutputSchema
  },
  portfolio_snapshot: {
    id: 'portfolio_snapshot',
    title: 'Portfolio Snapshot',
    dependencies: STAGE_DEPENDENCIES.portfolio_snapshot,
    promptBuilder: buildPortfolioSnapshotPrompt,
    validationSchema: portfolioSnapshotOutputSchema
  },
  deal_activity: {
    id: 'deal_activity',
    title: 'Recent Investments and Add-ons',
    dependencies: STAGE_DEPENDENCIES.deal_activity,
    promptBuilder: buildDealActivityPrompt,
    validationSchema: dealActivityOutputSchema
  },
  deal_team: {
    id: 'deal_team',
    title: 'Deal Team and Key Stakeholders',
    dependencies: STAGE_DEPENDENCIES.deal_team,
    promptBuilder: buildDealTeamPrompt,
    validationSchema: dealTeamOutputSchema
  },
  portfolio_maturity: {
    id: 'portfolio_maturity',
    title: 'Portfolio Maturity and Exit Watchlist',
    dependencies: STAGE_DEPENDENCIES.portfolio_maturity,
    promptBuilder: buildPortfolioMaturityPrompt,
    validationSchema: portfolioMaturityOutputSchema
  },
  leadership_and_governance: {
    id: 'leadership_and_governance',
    title: 'Leadership and Governance',
    dependencies: STAGE_DEPENDENCIES.leadership_and_governance,
    promptBuilder: buildLeadershipAndGovernancePrompt,
    validationSchema: leadershipAndGovernanceOutputSchema
  },
  strategic_priorities: {
    id: 'strategic_priorities',
    title: 'Strategic Priorities and Transformation',
    dependencies: STAGE_DEPENDENCIES.strategic_priorities,
    promptBuilder: buildStrategicPrioritiesPrompt,
    validationSchema: strategicPrioritiesOutputSchema
  },
  operating_capabilities: {
    id: 'operating_capabilities',
    title: 'Operating Capabilities',
    dependencies: STAGE_DEPENDENCIES.operating_capabilities,
    promptBuilder: buildOperatingCapabilitiesPrompt,
    validationSchema: operatingCapabilitiesOutputSchema
  },
  segment_analysis: {
    id: 'segment_analysis',
    title: 'Segment Analysis',
    dependencies: STAGE_DEPENDENCIES.segment_analysis,
    promptBuilder: buildSegmentAnalysisPrompt,
    validationSchema: segmentAnalysisOutputSchema
  },
  trends: {
    id: 'trends',
    title: 'Market Trends',
    dependencies: STAGE_DEPENDENCIES.trends,
    promptBuilder: buildTrendsPrompt,
    validationSchema: trendsOutputSchema
  },
  peer_benchmarking: {
    id: 'peer_benchmarking',
    title: 'Peer Benchmarking',
    dependencies: STAGE_DEPENDENCIES.peer_benchmarking,
    promptBuilder: buildPeerBenchmarkingPrompt,
    validationSchema: peerBenchmarkingOutputSchema
  },
  sku_opportunities: {
    id: 'sku_opportunities',
    title: 'SKU Opportunities',
    dependencies: STAGE_DEPENDENCIES.sku_opportunities,
    promptBuilder: buildSkuOpportunitiesPrompt,
    validationSchema: skuOpportunitiesOutputSchema
  },
  recent_news: {
    id: 'recent_news',
    title: 'Recent News',
    dependencies: STAGE_DEPENDENCIES.recent_news,
    promptBuilder: buildRecentNewsPrompt,
    validationSchema: recentNewsOutputSchema
  },
  conversation_starters: {
    id: 'conversation_starters',
    title: 'Conversation Starters',
    dependencies: STAGE_DEPENDENCIES.conversation_starters,
    promptBuilder: buildConversationStartersPrompt,
    validationSchema: conversationStartersOutputSchema
  },
  appendix: {
    id: 'appendix',
    title: 'Appendix & Sources',
    dependencies: STAGE_DEPENDENCIES.appendix,
    promptBuilder: () => '', // Auto-generated
    validationSchema: appendixOutputSchema,
    isAutoGenerated: true
  }
};

// ============================================================================
// ORCHESTRATOR CLASS
// ============================================================================

export class ResearchOrchestrator {
  private prisma: PrismaClient;
  private claudeClient: ClaudeClient;
  private queueLockId = BigInt(937451); // arbitrary global lock id
  private queueLoopRunning = false;
  private queueWatchdogStarted = false;
  private modelPricing: Record<string, { prompt: number; completion: number }> = {
    // USD per 1M tokens (set to 0 by default; adjust if pricing changes)
    'claude-sonnet-4-5': { prompt: 3, completion: 15 },
    default: { prompt: 0, completion: 0 }
  };

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.claudeClient = getClaudeClient();
    this.startQueueWatchdog();
  }

  /**
   * Create a new research job with all sub-jobs
   */
  async createJob(input: {
    companyName: string;
    geography: string;
    industry?: string;
    focusAreas?: string[];
    userId: string;
    normalizedCompany?: string;
    normalizedGeography?: string;
    normalizedIndustry?: string | null;
    domain?: string | null;
    normalizedDomain?: string | null;
    reportType?: 'GENERIC' | 'INDUSTRIALS' | 'PE' | 'FS';
    blueprintVersion?: string;
    reportInputs?: Record<string, unknown>;
    selectedSections?: string[];
    userAddedPrompt?: string;
    visibilityScope?: 'PRIVATE' | 'GROUP' | 'GENERAL';
    groupIds?: string[];
  }) {
    const requestedSections = Array.isArray(input.selectedSections) ? input.selectedSections : [];
    const normalizedSections = requestedSections
      .map((section) => section.trim())
      .filter((section) => section.length > 0);
    const requestedStageIds = normalizedSections.filter((section): section is StageId =>
      USER_SELECTABLE_STAGES.includes(section as StageId)
    );
    const requestedSet = requestedStageIds.length ? new Set(requestedStageIds) : new Set(USER_SELECTABLE_STAGES);
    requestedSet.add('appendix');

    const expandedStages = new Set<StageId>(['foundation']);
    const addStageWithDeps = (stage: StageId) => {
      expandedStages.add(stage);
      const deps = STAGE_DEPENDENCIES[stage] || [];
      deps.forEach((dep) => addStageWithDeps(dep));
    };
    requestedSet.forEach((stage) => addStageWithDeps(stage));

    const effectiveStages = DEFAULT_STAGE_ORDER.filter((stage) => expandedStages.has(stage));

    const job = await this.prisma.researchJob.create({
      data: {
        companyName: input.companyName,
        normalizedCompany: input.normalizedCompany || input.companyName.toLowerCase(),
        geography: input.geography,
        normalizedGeography: input.normalizedGeography || input.geography.toLowerCase(),
        industry: input.industry,
        normalizedIndustry: input.normalizedIndustry || (input.industry ? input.industry.toLowerCase() : null),
        domain: input.domain || null,
        normalizedDomain: input.normalizedDomain || (input.domain ? input.domain.toLowerCase() : null),
        focusAreas: input.focusAreas || [],
        reportType: input.reportType || 'GENERIC',
        selectedSections: Array.from(requestedSet),
        userAddedPrompt: input.userAddedPrompt,
        visibilityScope: input.visibilityScope || 'PRIVATE',
        status: 'queued',
        queuedAt: new Date(),
        progress: 0,
        userId: input.userId,
        metadata: {
          focusAreas: input.focusAreas || [],
          requestedSections: requestedStageIds,
          blueprintVersion: input.blueprintVersion || null,
          reportInputs: (input.reportInputs || {}) as Prisma.InputJsonValue,
          sourceTracking: {
            baseSourceCount: 0,
            sectionSources: {},
            quoteSources: {}
          }
        }
      }
    });

    await Promise.all(
      effectiveStages.map(stage =>
        this.prisma.researchSubJob.create({
          data: {
            researchId: job.id,
            stage,
            status: 'pending',
            dependencies: STAGE_DEPENDENCIES[stage]
          }
        })
      )
    );

    if (input.groupIds && input.groupIds.length) {
      await this.prisma.researchJobGroup.createMany({
        data: input.groupIds.map((groupId) => ({
          jobId: job.id,
          groupId
        })),
        skipDuplicates: true
      });
    }

    // Kick off queue processor in background (force restart to avoid stale flag)
    this.processQueue(true).catch(console.error);

    return job;
  }

  /**
   * Main queue processor - ensures only one job executes at a time using pg advisory lock
   */
  async processQueue(forceRestart = false) {
    if (this.queueLoopRunning && !forceRestart) return;
    if (forceRestart) {
      this.queueLoopRunning = false;
    }
    this.queueLoopRunning = true;

    try {
      while (true) {
        const queueResult = await this.prisma.$transaction(async (tx) => {
          let lockHeld = false;
          try {
            const lockAcquired = await this.tryAcquireLock(tx);
            if (!lockAcquired) {
              return { action: 'retry' as const };
            }
            lockHeld = true;

            const staleCount = await this.cleanupStaleRunningJobs(tx);

            const runningJobs = await tx.researchJob.findMany({
              where: { status: 'running' },
              select: {
                id: true,
                currentStage: true,
                startedAt: true,
                updatedAt: true,
                subJobs: {
                  select: { status: true, updatedAt: true, startedAt: true }
                }
              }
            });
            if (runningJobs.length > 0) {
              return { action: 'delay' as const, runningJobs, staleCount };
            }

            const jobToRun = await tx.researchJob.findFirst({
              where: { status: 'queued' },
              orderBy: { queuedAt: 'asc' },
              select: { id: true }
            });

            if (!jobToRun) {
              return { action: 'idle' as const, staleCount };
            }

            await tx.researchJob.update({
              where: { id: jobToRun.id },
              data: {
                status: 'running',
                startedAt: new Date()
              }
            });

            return { action: 'run' as const, jobId: jobToRun.id, staleCount };
          } finally {
            if (lockHeld) {
              await this.releaseLock(tx);
            }
          }
        });

        if (queueResult.action === 'retry') {
          await this.delay(750);
          continue;
        }

        if ('staleCount' in queueResult && queueResult.staleCount > 0) {
          console.log(`[queue] Cleaned ${queueResult.staleCount} stale running job(s)`);
        }

        if (queueResult.action === 'delay') {
          const summaries = queueResult.runningJobs.map((job) => {
            const counts = {
              pending: 0,
              running: 0,
              completed: 0,
              failed: 0,
              cancelled: 0
            };
            let lastSubJobUpdate = 0;
            for (const subJob of job.subJobs) {
              switch (subJob.status) {
                case 'pending':
                  counts.pending += 1;
                  break;
                case 'running':
                  counts.running += 1;
                  break;
                case 'completed':
                  counts.completed += 1;
                  break;
                case 'failed':
                  counts.failed += 1;
                  break;
                case 'cancelled':
                  counts.cancelled += 1;
                  break;
                default:
                  break;
              }
              const updatedAt = subJob.updatedAt?.getTime?.() ?? 0;
              const startedAt = subJob.startedAt?.getTime?.() ?? 0;
              lastSubJobUpdate = Math.max(lastSubJobUpdate, updatedAt, startedAt);
            }
            const lastActivity = Math.max(
              lastSubJobUpdate,
              job.updatedAt?.getTime?.() ?? 0,
              job.startedAt?.getTime?.() ?? 0
            );
            return {
              id: job.id,
              currentStage: job.currentStage,
              startedAt: job.startedAt?.toISOString() ?? null,
              updatedAt: job.updatedAt?.toISOString() ?? null,
              subJobCounts: counts,
              lastSubJobUpdate: lastSubJobUpdate ? new Date(lastSubJobUpdate).toISOString() : null,
              lastActivity: lastActivity ? new Date(lastActivity).toISOString() : null
            };
          });
          console.log('[queue] Detected running job, delaying promotion', summaries);
          await this.delay(750);
          continue;
        }

        if (queueResult.action === 'idle') {
          break;
        }

        console.log('[queue] Promoting job to running:', queueResult.jobId);
        await this.executeJob(queueResult.jobId);

        // Small gap before next iteration to avoid tight loop
        await this.delay(200);
      }
    } catch (error) {
      console.error('Queue processor error:', error);
    } finally {
      this.queueLoopRunning = false;
    }
  }

  /**
   * Execute the entire research job
   */
  async executeJob(jobId: string) {
    try {
      const existing = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true }
      });
      if (!existing || existing.status === 'cancelled') {
        return;
      }

      await this.updateJobStatus(jobId, 'running');

      // Execute stages in dependency order
      await this.executeNextPhase(jobId);

      // Finalize status based on sub-job results
      const subJobs = await this.prisma.researchSubJob.findMany({
        where: { researchId: jobId },
        select: { status: true, stage: true }
      });

      const current = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true }
      });
      if (!current) return;

      const finalStatus = computeFinalStatus(current.status, subJobs);
      if (finalStatus !== current.status) {
        await this.updateJobStatus(jobId, finalStatus);
      }

      if (finalStatus === 'completed' || finalStatus === 'completed_with_errors') {
        await this.triggerThumbnail(jobId);
      }
    } catch (error) {
      console.error(`Job ${jobId} failed:`, error);
      await this.updateJobStatus(jobId, 'failed');
    } finally {
      // Ensure the queue loop continues after this job finishes
      this.processQueue().catch(console.error);
    }
  }

  /**
   * Execute the next phase of stages (dependency-aware)
   */
  private async executeNextPhase(jobId: string) {
    const cancelled = await this.isJobCancelled(jobId);
    if (cancelled) return;

    const runnable = await this.getNextRunnableStages(jobId);

    if (runnable.length === 0) {
      // Check if job is complete
      await this.checkJobCompletion(jobId);
      return;
    }

    // Execute runnable stages sequentially to ensure only one Claude call at a time
    for (const stage of runnable) {
      const cancelledMidway = await this.isJobCancelled(jobId);
      if (cancelledMidway) return;
      await this.executeStage(jobId, stage);
    }

    // After this phase completes, check for next phase
    await this.executeNextPhase(jobId);
  }

  /**
   * Get stages that can run now (dependencies met)
   */
  private async getNextRunnableStages(jobId: string): Promise<StageId[]> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job || job.status === 'cancelled') return [];

    const completed = new Set(
      job.subJobs
        .filter(j => j.status === 'completed')
        .map(j => j.stage as StageId)
    );

    const running = new Set(
      job.subJobs
        .filter(j => j.status === 'running')
        .map(j => j.stage as StageId)
    );

    const pending = job.subJobs
      .filter(j => j.status === 'pending')
      .map(j => j.stage as StageId);

    const runnable: StageId[] = [];

    for (const stage of pending) {
      const deps = STAGE_DEPENDENCIES[stage] || [];
      const depsCompleted = deps.every(dep => completed.has(dep));
      const notRunning = !running.has(stage);

      if (depsCompleted && notRunning) {
        runnable.push(stage);
      }
    }

    return runnable;
  }

  /**
   * Execute a single stage
   */
  private async executeStage(jobId: string, stageId: StageId) {
    let response: ClaudeResponse | null = null;
    try {
      const job = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true, reportType: true }
      });
      if (!job || job.status === 'cancelled') {
        return;
      }
      const reportType = (job.reportType as ReportTypeId) || 'GENERIC';
      // Mark as running
      await this.updateSubJobStatus(jobId, stageId, 'running');
      await this.updateJobCurrentStage(jobId, stageId);

      const startTime = Date.now();

      // Handle appendix auto-generation
      if (stageId === 'appendix') {
        await this.executeAppendix(jobId);
        const duration = Date.now() - startTime;
        await this.completeSubJob(jobId, stageId, duration);
        return;
      }

      // Build prompt with context
      const prompt = await this.buildStagePrompt(jobId, stageId);

      // Execute with Claude
      const initialResponse = await this.claudeClient.execute(prompt);
      response = initialResponse;

      // Parse and validate
      const validationSchema = getValidationSchema(stageId, reportType);
      let output: any;
      try {
        output = this.parseStageOutput(stageId, initialResponse, validationSchema);
      } catch (error) {
        if (!this.shouldRetryFormatOnly(error)) {
          throw error;
        }

        console.warn(`[format-only] ${stageId} attempting JSON reformat`);
        const formatPrompt = this.buildFormatOnlyPrompt(prompt, initialResponse.content);
        const formatResponse = await this.claudeClient.execute(formatPrompt);
        response = formatResponse;

        try {
          output = this.parseStageOutput(stageId, formatResponse, validationSchema);
        } catch (formatError) {
          if (stageId !== 'financial_snapshot') {
            throw formatError;
          }

          console.warn(`[schema-only] ${stageId} attempting minimal schema regeneration`);
          const schemaPrompt = await this.buildFinancialSnapshotSchemaOnlyPrompt(jobId, reportType);
          const schemaResponse = await this.claudeClient.execute(schemaPrompt);
          response = schemaResponse;
          output = this.parseStageOutput(stageId, schemaResponse, validationSchema);
        }
      }

      // Sanitize common issues before content check/save
      if (stageId === 'exec_summary') {
        output = this.sanitizeExecSummary(output);
      } else if (stageId === 'segment_analysis') {
        output = this.sanitizeSegmentAnalysis(output);
      } else if (stageId === 'peer_benchmarking') {
        output = this.sanitizePeerBenchmarking(output);
      }

      // Guard against empty/invalid content that passed validation
      this.ensureStageHasContent(stageId, output);

      await this.recordTokenUsage(jobId, stageId, response!);

      const stillActive = await this.prisma.researchJob.findUnique({
        where: { id: jobId },
        select: { status: true }
      });
      if (!stillActive || stillActive.status === 'cancelled') {
        return;
      }

      // Save output
      await this.saveStageOutput(jobId, stageId, output);

      const duration = Date.now() - startTime;
      await this.completeSubJob(jobId, stageId, duration);

    } catch (error) {
      console.error(`Stage ${stageId} failed:`, error);
      const rawContent = response?.content;
      await this.handleStageFailure(jobId, stageId, error, rawContent);

      // If this stage is now marked failed (exceeded retries), fail foundation immediately.
      const sub = await this.prisma.researchSubJob.findFirst({
        where: { researchId: jobId, stage: stageId },
        select: { status: true }
      });
      if (sub?.status === 'failed') {
        if (stageId === 'foundation') {
          await this.updateJobStatus(jobId, 'failed');
          throw error;
        }
        await this.updateProgress(jobId);
      }
    }
  }

  /**
   * Build prompt with all required context
   */
  private async buildStagePrompt(jobId: string, stageId: StageId): Promise<string> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job) throw new Error('Job not found');

    const config = STAGE_CONFIGS[stageId];
    
    // Build input object with all required context
    const input: any = {
      companyName: job.companyName,
      geography: job.geography,
      foundation: job.foundation,
      reportType: (job.reportType as ReportTypeId) || 'GENERIC'
    };

    // Add optional context based on dependencies
    if (job.financialSnapshot) input.section2 = job.financialSnapshot;
    if (job.companyOverview) input.section3 = job.companyOverview;
    if (job.segmentAnalysis) input.section4 = job.segmentAnalysis;
    if (job.trends) input.section5 = job.trends;
    if (job.peerBenchmarking) input.section6 = job.peerBenchmarking;
    if (job.skuOpportunities) input.section7 = job.skuOpportunities;
    if (job.recentNews) input.section8 = job.recentNews;

    const basePrompt = config.promptBuilder(input);
    const userPrompt = typeof job.userAddedPrompt === 'string' ? job.userAddedPrompt.trim() : '';
    const reportInputsText = this.formatReportInputs(job);
    const promptSections = [basePrompt];
    if (reportInputsText) {
      promptSections.push(
        [
          '---',
          '',
          '## REPORT INPUTS (PRIORITY)',
          '',
          'Use these inputs as primary constraints for scope, emphasis, and tone.',
          'If any input conflicts with other context, follow the report inputs.',
          '',
          reportInputsText
        ].join('\n')
      );
    }
    if (userPrompt) {
      promptSections.push(`---\n\n## USER-ADDED CONTEXT\n\n${userPrompt}`);
    }

    return promptSections.join('\n\n');
  }

  private formatReportInputs(job: { reportType: string; metadata: Prisma.JsonValue }): string | null {
    if (!job.metadata || typeof job.metadata !== 'object' || Array.isArray(job.metadata)) {
      return null;
    }

    const metadata = job.metadata as Record<string, unknown>;
    const rawInputs = metadata.reportInputs;
    if (!rawInputs || typeof rawInputs !== 'object' || Array.isArray(rawInputs)) {
      return null;
    }

    const reportInputs = rawInputs as Record<string, unknown>;
    const blueprint = getReportBlueprint(job.reportType as ReportTypeId);
    const orderedEntries: Array<{ key: string; label: string; value: unknown }> = [];
    const seen = new Set<string>();

    const normalizedLabels: Record<string, string> = {
      companyName: 'Company name',
      timeHorizon: 'Time horizon',
      meetingContext: 'Meeting context',
      segmentFocus: 'Segment or end market focus',
      topicOfInterest: 'Topic of interest',
      fundStrategy: 'Fund or strategy focus',
      businessFocus: 'Business focus',
      stakeholders: 'Stakeholders'
    };

    const addEntry = (key: string, label: string, value: unknown) => {
      orderedEntries.push({ key, label, value });
      seen.add(key);
    };

    for (const [key, label] of Object.entries(normalizedLabels)) {
      if (Object.prototype.hasOwnProperty.call(reportInputs, key)) {
        addEntry(key, label, reportInputs[key]);
      }
    }

    if (blueprint) {
      for (const input of blueprint.inputs) {
        if (Object.prototype.hasOwnProperty.call(reportInputs, input.id) && !seen.has(input.id)) {
          addEntry(input.id, input.label, reportInputs[input.id]);
        }
      }
    }

    for (const [key, value] of Object.entries(reportInputs)) {
      if (!seen.has(key)) {
        addEntry(key, key, value);
      }
    }

    const lines = orderedEntries
      .map(({ label, value }) => {
        const formatted = this.formatReportInputValue(value);
        return formatted ? `- ${label}: ${formatted}` : null;
      })
      .filter((line): line is string => Boolean(line));

    return lines.length ? lines.join('\n') : null;
  }

  private formatReportInputValue(value: unknown): string | null {
    if (value === null || value === undefined) return null;
    if (typeof value === 'string') {
      const trimmed = value.trim();
      return trimmed.length ? trimmed : null;
    }
    if (typeof value === 'number' || typeof value === 'boolean') {
      return String(value);
    }
    if (Array.isArray(value)) {
      const parts = value
        .map((item) => this.formatReportInputValue(item))
        .filter((item): item is string => Boolean(item));
      return parts.length ? parts.join(', ') : null;
    }
    if (typeof value === 'object') {
      const json = JSON.stringify(value);
      return json && json !== '{}' && json !== '[]' ? json : null;
    }
    return String(value);
  }

  /**
   * Execute appendix (auto-generated)
   */
  private async executeAppendix(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId }
    });

    if (!job || !job.foundation) {
      throw new Error('Foundation not available for appendix generation');
    }

    const sections: any = {
      section1: job.execSummary,
      section2: job.financialSnapshot,
      section3: job.companyOverview,
      section4: job.segmentAnalysis,
      section5: job.trends,
      section6: job.peerBenchmarking,
      section7: job.skuOpportunities,
      section8: job.recentNews,
      section9: job.conversationStarters
    };

    const appendixOutput = generateAppendix({
      foundation: job.foundation as unknown as FoundationOutput,
      companyName: job.companyName,
      geography: job.geography,
      sections
    });

    await this.saveStageOutput(jobId, 'appendix', appendixOutput);
  }

  /**
   * Save stage output to database
   */
  private async saveStageOutput(jobId: string, stageId: StageId, output: any) {
    const field = STAGE_OUTPUT_FIELDS[stageId];
    if (field) {
      await this.tryUpdateJob(jobId, {
        [field]: output,
        overallConfidence: output.confidence?.level || 'MEDIUM'
      });
    } else {
      await this.tryUpdateJob(jobId, {
        overallConfidence: output.confidence?.level || 'MEDIUM'
      });
    }

    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        output,
        confidence: output.confidence?.level || 'MEDIUM',
        sourcesUsed: output.sources_used || []
      }
    });

    await this.updateOverallConfidence(jobId);
  }

  /**
   * Complete a sub-job
   */
  private async completeSubJob(jobId: string, stageId: StageId, duration: number) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage: stageId },
      data: {
        status: 'completed',
        completedAt: new Date(),
        duration
      }
    });

    await this.updateProgress(jobId);
  }

  /**
   * Handle stage failure with retry logic
   */
  private async handleStageFailure(jobId: string, stageId: StageId, error: unknown, rawContent?: string) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    const subJob = await this.prisma.researchSubJob.findFirst({
      where: { researchId: jobId, stage: stageId }
    });

    if (!subJob) return;

    const attempts = subJob.attempts + 1;

    if (attempts < subJob.maxAttempts) {
      const isRateLimit = this.isRateLimitError(errorMessage);
      const isServerError = this.isServerError(errorMessage);
      if (isRateLimit || isServerError) {
        await this.delay(2000);
      }
      console.log(`[retry] ${stageId} attempt ${attempts}/${subJob.maxAttempts} after error: ${errorMessage}`);
      // Retry
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          attempts,
          lastError: errorMessage,
          output: (rawContent ? { rawContent, error: errorMessage } : subJob.output) as any,
          status: 'pending'
        }
      });
    } else {
      // Max retries exceeded
      await this.prisma.researchSubJob.update({
        where: { id: subJob.id },
        data: {
          status: 'failed',
          lastError: errorMessage,
          output: (rawContent ? { rawContent, error: errorMessage } : subJob.output) as any
        }
      });

      const subJobs = await this.prisma.researchSubJob.findMany({
        where: { researchId: jobId },
        select: { stage: true, status: true }
      });
      const blockedStages = collectBlockedStages([stageId], subJobs, STAGE_DEPENDENCIES);
      if (blockedStages.length > 0) {
        await this.prisma.researchSubJob.updateMany({
          where: {
            researchId: jobId,
            stage: { in: blockedStages },
            status: { in: ['pending', 'running'] }
          },
          data: {
            status: 'failed',
            lastError: `Blocked by failed dependency: ${stageId}`
          }
        });
      }

      await this.updateOverallConfidence(jobId);
    }
  }

  /**
   * Update job status
   */
  private async updateJobStatus(jobId: string, status: string) {
    const current = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { status: true }
    });

    if (!current) return;

    // Do not overwrite a cancelled job with another status
    if (current.status === 'cancelled' && status !== 'cancelled') {
      return;
    }

    if (current.status !== status) {
      await this.tryUpdateJob(jobId, { status });
    }

    if (status === 'cancelled') {
      // Mark running/pending subjobs as cancelled too
      await this.prisma.researchSubJob.updateMany({
        where: { researchId: jobId, status: { in: ['pending', 'running'] } },
        data: { status: 'cancelled', completedAt: new Date() }
      });
    }
  }

  /**
   * Update current stage
   */
  private async updateJobCurrentStage(jobId: string, stage: StageId) {
    await this.tryUpdateJob(jobId, { currentStage: stage });
  }

  /**
   * Update sub-job status
   */
  private async updateSubJobStatus(jobId: string, stage: StageId, status: string) {
    await this.prisma.researchSubJob.updateMany({
      where: { researchId: jobId, stage },
      data: { status }
    });
  }

  /**
   * Update progress
   */
  private async updateProgress(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    const progress = computeTerminalProgress(job.subJobs);

    await this.tryUpdateJob(jobId, { progress });
  }

  /**
   * Check if job is complete
   */
  private async checkJobCompletion(jobId: string) {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      include: { subJobs: true }
    });

    if (!job) return;

    if (job.status === 'cancelled') {
      return;
    }

    const finalStatus = computeFinalStatus(job.status, job.subJobs);
    if (finalStatus === job.status) {
      return;
    }

    await this.updateJobStatus(jobId, finalStatus);

    if (finalStatus === 'completed' || finalStatus === 'completed_with_errors') {
      await this.triggerThumbnail(jobId);
    }
  }

  /**
   * Recompute overall confidence score/label from completed sub-jobs
   */
  private async updateOverallConfidence(jobId: string) {
    const subJobs = await this.prisma.researchSubJob.findMany({
      where: { researchId: jobId, status: { in: ['completed', 'failed'] } },
      select: { confidence: true, status: true }
    });

    const { score, label } = computeOverallConfidence(subJobs);

    if (score === null || label === null) {
      await this.tryUpdateJob(jobId, {
        overallConfidence: null,
        overallConfidenceScore: null
      });
      return;
    }

    await this.tryUpdateJob(jobId, {
      overallConfidence: label,
      overallConfidenceScore: score
    });
  }

  private sanitizeExecSummary(output: any) {
    const bullets = Array.isArray(output?.bullet_points)
      ? output.bullet_points
          .map((b: any) => ({
            ...b,
            bullet: typeof b?.bullet === 'string' ? b.bullet.trim() : String(b?.bullet ?? '').trim()
          }))
          .filter((b: any) => b.bullet.length > 0)
      : [];

    return {
      ...output,
      bullet_points: bullets
    };
  }

  private sanitizeSegmentAnalysis(output: any) {
    const rawSources = Array.isArray(output?.sources_used) ? output.sources_used : [];
    const cleanedSources = Array.from(
      new Set(
        rawSources
          .map((s: any) => (typeof s === 'string' ? s.trim() : String(s ?? '').trim()))
          .filter((s: string) => /^S\d+$/.test(s))
      )
    );

    const segments = Array.isArray(output?.segments) ? output.segments.map((seg: any) => {
      const comp = Array.isArray(seg?.competitive_landscape?.competitors)
        ? seg.competitive_landscape.competitors.slice(0, 5) // cap to max 5 to avoid validation failure
        : [];
      return {
        ...seg,
        competitive_landscape: {
          ...(seg?.competitive_landscape || {}),
          competitors: comp
        }
      };
    }) : [];

    return {
      ...output,
      sources_used: cleanedSources,
      segments
    };
  }

  private sanitizePeerBenchmarking(output: any) {
    if (!output || typeof output !== 'object') return output;
    const table = output.peer_comparison_table;
    if (!table || !Array.isArray(table.peers)) return output;

    const peers = table.peers.map((peer: any) => ({
      ...peer,
      ticker: typeof peer?.ticker === 'string' ? peer.ticker.trim() : '',
      geography_presence: typeof peer?.geography_presence === 'string' ? peer.geography_presence.trim() : ''
    }));

    return {
      ...output,
      peer_comparison_table: {
        ...table,
        peers
      }
    };
  }

  private shouldRetryFormatOnly(error: unknown): boolean {
    const message = error instanceof Error ? error.message : String(error ?? '');
    return (
      message.includes('Failed to parse JSON response') ||
      message.includes('Expected object, received array') ||
      message.includes('Schema validation failed')
    );
  }

  private buildFormatOnlyPrompt(originalPrompt: string, rawContent: string): string {
    return [
      'FORMAT-ONLY TASK',
      '',
      'You produced output that failed JSON parsing.',
      'Return ONLY valid JSON matching the schema in the original prompt.',
      'Do NOT add new facts. Preserve the content; only fix formatting.',
      'Remove headings, commentary, markdown, or code fences.',
      'If the prior output is an array with a single object, return just that object.',
      '',
      'ORIGINAL PROMPT (schema reference):',
      '```',
      originalPrompt,
      '```',
      '',
      'PRIOR OUTPUT TO REFORMAT:',
      '```',
      rawContent,
      '```',
      '',
      'OUTPUT ONLY JSON.'
    ].join('\n');
  }

  private getFinancialSnapshotRequiredKpis(reportType: ReportTypeId): string[] {
    switch (reportType) {
      case 'INDUSTRIALS':
        return [
          'Revenue (Latest Period) ($M)',
          'Revenue Growth (YoY) (%)',
          'Gross Margin (%)',
          'EBITDA ($M)',
          'EBITDA Margin (%)',
          'Operating Income (EBIT) ($M)',
          'Operating Margin (%)',
          'Net Income ($M)',
          'Net Margin (%)',
          'Free Cash Flow ($M)',
          'CapEx ($M)',
          'Cash and Equivalents ($M)',
          'Total Debt ($M)',
          'Net Debt ($M)',
          'Net Leverage (x)',
          'Days Sales Outstanding (DSO) (days)',
          'Days Inventory Outstanding (DIO) (days)',
          'Inventory Turns (x)',
          'Days Payable Outstanding (DPO) (days)',
          'Working Capital ($M)'
        ];
      case 'PE':
        return [
          'Assets Under Management (AUM) ($B)',
          'Fund Size (Latest Fund) ($B)',
          'Dry Powder ($B)',
          'Fee-Related Earnings ($M)',
          'Fee-Related Earnings Margin (%)',
          'Management Fee Rate (%)',
          'Realized Value (DPI) (x)',
          'Total Value (TVPI) (x)',
          'Net IRR (%)',
          'Active Portfolio Companies (Count)',
          'Typical Hold Period (years)',
          'Recent Exits (Count, 12-24 months)'
        ];
      case 'FS':
        return [
          'Total Assets ($B)',
          'Revenue (or Net Revenue) ($M)',
          'Net Interest Margin (%)',
          'Efficiency Ratio (%)',
          'Return on Equity (ROE) (%)',
          'Return on Assets (ROA) (%)',
          'CET1 Ratio (or Primary Capital Ratio) (%)',
          'Loan/Deposit Ratio (%)',
          'Non-Performing Loan Ratio (%)',
          'Cost of Risk / Credit Loss Ratio (%)',
          'Liquidity Coverage Ratio (%)',
          'Net New Assets / AUM ($B)'
        ];
      default:
        return [
          'Revenue ($M)',
          'Revenue Growth (YoY) (%)',
          'EBITDA (or Operating Income) ($M)',
          'EBITDA Margin (or Operating Margin) (%)',
          'Net Income ($M)',
          'Net Margin (%)',
          'Free Cash Flow ($M)',
          'Cash and Equivalents ($M)',
          'Total Debt ($M)',
          'Net Debt ($M)'
        ];
    }
  }

  private async buildFinancialSnapshotSchemaOnlyPrompt(
    jobId: string,
    reportType: ReportTypeId
  ): Promise<string> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { companyName: true, geography: true, foundation: true }
    });

    if (!job) {
      throw new Error('Job not found for schema-only regeneration');
    }

    const requiredKpis = this.getFinancialSnapshotRequiredKpis(reportType);
    const requiredKpiList = requiredKpis.map((metric, index) => `${index + 1}. ${metric}`).join('\n');
    const foundationJson = JSON.stringify(job.foundation ?? {}, null, 2);

    return [
      'FORMAT-ONLY TASK',
      '',
      'Regenerate Section 2 (Financial Snapshot) output as a VALID JSON object matching the schema below.',
      'Do NOT add new facts. Use only the provided foundation context.',
      'If a value is missing, use "-" for company/industry_avg and keep sources_used empty if needed.',
      'If you use placeholders, set confidence.level to LOW and note schema-only regeneration in the reason.',
      'If a source is unknown, set source to "-".',
      'No markdown, no headings, no code fences.',
      '',
      'Schema:',
      '{',
      '  "confidence": { "level": "HIGH|MEDIUM|LOW", "reason": "string" },',
      '  "summary": "string",',
      '  "kpi_table": { "metrics": [ { "metric": "string", "company": "number|string", "industry_avg": "number|string", "source": "string" } ] },',
      '  "fx_source": "A|B|C",',
      '  "industry_source": "A|B|C",',
      '  "derived_metrics": [ { "metric": "string", "formula": "string", "calculation": "string", "source": "string" } ],',
      '  "sources_used": ["S1", "S2"]',
      '}',
      '',
      'Required KPI metrics (use "-" if unavailable):',
      requiredKpiList,
      '',
      `Company: ${job.companyName}`,
      `Geography: ${job.geography}`,
      '',
      'Foundation context (JSON):',
      'BEGIN_FOUNDATION_JSON',
      foundationJson,
      'END_FOUNDATION_JSON',
      '',
      'OUTPUT ONLY JSON.'
    ].join('\n');
  }

  private parseStageOutput(stageId: StageId, response: ClaudeResponse, validationSchema: any) {
    if (stageId !== 'financial_snapshot') {
      return this.claudeClient.validateAndParse(response, validationSchema, { allowRepair: true });
    }

    const parsed = this.claudeClient.parseJSON<any>(response, { allowRepair: true });
    const normalized = this.normalizeFinancialSnapshotOutput(parsed);
    const result = validationSchema.safeParse(normalized);

    if (!result.success) {
      throw new Error(`Schema validation failed: ${result.error.message}`);
    }

    return result.data;
  }

  private normalizeFinancialSnapshotOutput(output: any) {
    if (!output || typeof output !== 'object') return output;
    const source = Array.isArray(output)
      ? (output.length === 1 && output[0] && typeof output[0] === 'object' ? output[0] : output)
      : output;

    if (!source || typeof source !== 'object' || Array.isArray(source)) {
      return source;
    }

    const normalized: Record<string, any> = { ...source };
    const content = source.content && typeof source.content === 'object' ? source.content : null;

    if (!normalized.summary && content?.summary) {
      normalized.summary = content.summary;
    }

    if (!normalized.kpi_table && content?.tables && Array.isArray(content.tables)) {
      const table = content.tables[0];
      const headers = Array.isArray(table?.headers)
        ? table.headers.map((h: string) => h.toLowerCase())
        : [];
      const metricIdx = headers.findIndex((h: string) => h.includes('metric'));
      const companyIdx = headers.findIndex((h: string) => h.includes('company'));
      const industryIdx = headers.findIndex((h: string) => h.includes('industry'));
      const sourceIdx = headers.findIndex((h: string) => h.includes('source'));

      const rows = Array.isArray(table?.rows) ? table.rows : [];
      const metrics = rows
        .map((row: any) => {
          if (!Array.isArray(row)) return null;
          const fallback = {
            metric: row[0],
            company: row[1],
            industry_avg: row[2],
            source: row[3]
          };
          const mapped = {
            metric: row[metricIdx] ?? fallback.metric,
            company: row[companyIdx] ?? fallback.company,
            industry_avg: row[industryIdx] ?? fallback.industry_avg,
            source: row[sourceIdx] ?? fallback.source
          };
          return mapped.metric ? mapped : null;
        })
        .filter(Boolean);

      if (metrics.length) {
        normalized.kpi_table = { metrics };
      }
    }

    if (!normalized.kpi_table && Array.isArray(source.kpi_table?.table)) {
      normalized.kpi_table = { metrics: source.kpi_table.table };
    }

    if (!normalized.sources_used && Array.isArray(source.sources)) {
      normalized.sources_used = source.sources;
    }

    if (!normalized.derived_metrics && Array.isArray(content?.derived_metrics)) {
      normalized.derived_metrics = content.derived_metrics;
    }

    if (!normalized.fx_source && source.fx_rate_source) {
      normalized.fx_source = source.fx_rate_source;
    }

    if (!normalized.industry_source && source.industry_avg_source) {
      normalized.industry_source = source.industry_avg_source;
    }

    if (normalized.kpi_table?.metrics && Array.isArray(normalized.derived_metrics)) {
      const metrics = Array.isArray(normalized.kpi_table.metrics)
        ? [...normalized.kpi_table.metrics]
        : [];
      const normalizeMetricName = (name: string) =>
        name
          .replace(/\s*\([^)]*\)\s*$/, '')
          .replace(/\*$/, '')
          .trim()
          .toLowerCase();
      const existingNames = new Set<string>();
      const baseIndex = new Map<string, number>();
      metrics.forEach((metric, index) => {
        const name = typeof metric?.metric === 'string' ? metric.metric : '';
        if (!name) return;
        existingNames.add(name);
        const base = normalizeMetricName(name);
        if (base) baseIndex.set(base, index);
      });

      for (const derived of normalized.derived_metrics) {
        const baseName = typeof derived?.metric === 'string' ? derived.metric.trim() : '';
        if (!baseName) continue;
        const derivedValue = this.extractDerivedMetricValue(derived?.calculation);
        const baseKey = normalizeMetricName(baseName);
        const matchIndex = baseKey ? baseIndex.get(baseKey) : undefined;

        if (matchIndex !== undefined) {
          const existing = metrics[matchIndex];
          if (existing && typeof existing.metric === 'string' && !existing.metric.endsWith('*')) {
            existing.metric = `${existing.metric}*`;
          }
          if ((existing?.company === undefined || existing?.company === '-' || existing?.company === null) && derivedValue) {
            existing.company = derivedValue;
          }
          if (!existing?.source && derived?.source) {
            existing.source = derived.source;
          }
          continue;
        }

        const tableName = baseName.endsWith('*') ? baseName : `${baseName}*`;
        if (existingNames.has(tableName)) continue;

        metrics.push({
          metric: tableName,
          company: derivedValue ?? '-',
          industry_avg: '-',
          source: derived?.source || '-'
        });
        existingNames.add(tableName);
      }

      normalized.kpi_table = { metrics };
    }

    return normalized;
  }

  private extractDerivedMetricValue(calculation: string | undefined | null): string | null {
    if (!calculation || typeof calculation !== 'string') return null;
    const match = calculation.match(/=\s*([^\n]+)$/);
    const candidate = match ? match[1].trim() : '';
    if (!candidate) return null;
    return candidate.replace(/[.;]$/, '').trim();
  }

  /**
   * Ensure a section output has meaningful content; throw if empty to force retry/failure
   */
  private ensureStageHasContent(stageId: StageId, output: any) {
    if (!output || typeof output !== 'object') {
      throw new Error(`Stage ${stageId} returned empty output`);
    }

    if (stageId === 'exec_summary') {
      const bullets = Array.isArray(output.bullet_points) ? output.bullet_points.length : 0;
      if (bullets < 3) {
        throw new Error('Executive Summary missing bullet_points');
      }
    }

    if (stageId === 'segment_analysis') {
      const segments = Array.isArray(output.segments) ? output.segments.length : 0;
      if (!output.overview && segments === 0) {
        throw new Error('Segment Analysis missing overview or segments');
      }
    }
  }

  /**
   * Track token usage and estimated cost for each call
   */
  private async recordTokenUsage(jobId: string, stageId: StageId, response: ClaudeResponse) {
    const inputTokens = response.usage?.inputTokens || 0;
    const outputTokens = response.usage?.outputTokens || 0;
    const model = typeof this.claudeClient.getModelName === 'function'
      ? this.claudeClient.getModelName()
      : process.env.CLAUDE_MODEL || 'claude-sonnet-4-5';

    const pricing = this.modelPricing[model] || this.modelPricing.default;
    const costUsd = ((inputTokens * pricing.prompt) + (outputTokens * pricing.completion)) / 1_000_000;

    try {
      await this.prisma.$transaction([
        this.prisma.researchSubJob.updateMany({
          where: { researchId: jobId, stage: stageId },
          data: {
            promptTokens: { increment: inputTokens },
            completionTokens: { increment: outputTokens },
            costUsd: { increment: costUsd }
          }
        }),
        this.prisma.researchJob.update({
          where: { id: jobId },
          data: {
            promptTokens: { increment: inputTokens },
            completionTokens: { increment: outputTokens },
            costUsd: { increment: costUsd }
          }
        })
      ]);
    } catch (error) {
      if (this.isRecordNotFound(error)) {
        return;
      }
      throw error;
    }
  }

  /**
   * Compute queue position for a job (running job counts as position 0)
   */
  async getQueuePosition(jobId: string): Promise<number> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { status: true, queuedAt: true, createdAt: true }
    });
    if (!job) return 0;

    const anchor = job.queuedAt || job.createdAt;
    const queuedAhead = await this.prisma.researchJob.count({
      where: {
        status: 'queued',
        queuedAt: { lt: anchor }
      }
    });
    const runningCount = await this.prisma.researchJob.count({
      where: { status: 'running' }
    });

    if (job.status === 'running') {
      return 0;
    }

    return queuedAhead + runningCount + 1;
  }

  // ============================================================================
  // Queue helpers
  // ============================================================================

  private async tryAcquireLock(client: Prisma.TransactionClient | PrismaClient = this.prisma): Promise<boolean> {
    const result = await client.$queryRaw<{ locked: boolean }[]>`
      SELECT pg_try_advisory_lock(${this.queueLockId}) AS locked
    `;
    return Boolean(result?.[0]?.locked);
  }

  private async releaseLock(client: Prisma.TransactionClient | PrismaClient = this.prisma) {
    await client.$queryRaw`
      SELECT pg_advisory_unlock(${this.queueLockId})
    `;
  }

  private async delay(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  private async isJobCancelled(jobId: string): Promise<boolean> {
    const job = await this.prisma.researchJob.findUnique({
      where: { id: jobId },
      select: { status: true }
    });
    return !job || job.status === 'cancelled';
  }

  private async tryUpdateJob(
    jobId: string,
    data: Record<string, unknown>,
    client: Prisma.TransactionClient | PrismaClient = this.prisma
  ) {
    try {
      await client.researchJob.update({
        where: { id: jobId },
        data
      });
    } catch (error) {
      if (this.isRecordNotFound(error)) {
        return;
      }
      throw error;
    }
  }

  private isRecordNotFound(error: unknown): boolean {
    return Boolean(
      error &&
        typeof error === 'object' &&
        'code' in error &&
        (error as { code?: string }).code === 'P2025'
    );
  }

  private async cleanupStaleRunningJobs(
    client: Prisma.TransactionClient | PrismaClient = this.prisma
  ): Promise<number> {
    const runningJobs = await client.researchJob.findMany({
      where: { status: 'running' },
      include: { subJobs: true }
    });

    let cleaned = 0;
    const now = Date.now();
    const staleThresholdMs = 30 * 60 * 1000;

    for (const job of runningJobs) {
      const statuses = job.subJobs.map((subJob) => subJob.status);
      const hasRunning = statuses.includes('running');
      const hasPending = statuses.includes('pending');
      const lastSubJobUpdate = job.subJobs.reduce((latest, subJob) => {
        const updated = subJob.updatedAt?.getTime?.() ?? 0;
        const started = subJob.startedAt?.getTime?.() ?? 0;
        return Math.max(latest, updated, started);
      }, 0);
      const lastJobUpdate = job.updatedAt?.getTime?.() ?? 0;
      const lastActivity = Math.max(lastSubJobUpdate, lastJobUpdate, job.startedAt?.getTime?.() ?? 0);
      const isStale = lastActivity > 0 && now - lastActivity > staleThresholdMs;

      if (hasRunning) {
        continue;
      }

      if (hasPending) {
        if (!isStale) {
          continue;
        }

        await client.researchSubJob.updateMany({
          where: { researchId: job.id, status: { in: ['running', 'pending'] } },
          data: { status: 'failed', completedAt: new Date() }
        });

        const terminalized = job.subJobs.map((subJob) => {
          if (subJob.status === 'running' || subJob.status === 'pending') {
            return { ...subJob, status: 'failed' };
          }
          return subJob;
        });
        const nextStatus = computeFinalStatus(job.status, terminalized);

        await this.tryUpdateJob(job.id, {
          status: nextStatus,
          currentStage: null,
          completedAt:
            nextStatus === 'completed' || nextStatus === 'completed_with_errors'
              ? new Date()
              : job.completedAt
        }, client);
        cleaned += 1;
        continue;
      }

      const nextStatus = computeFinalStatus(job.status, job.subJobs);

      await this.tryUpdateJob(job.id, {
        status: nextStatus,
        currentStage: null,
        completedAt:
          nextStatus === 'completed' || nextStatus === 'completed_with_errors'
            ? new Date()
            : job.completedAt
      }, client);
      cleaned += 1;
    }

    return cleaned;
  }

  /**
   * Kick off thumbnail generation for completed jobs (best-effort, non-blocking)
   */
  private async triggerThumbnail(jobId: string) {
    try {
      await generateThumbnailForJob(this.prisma, jobId);
    } catch (err) {
      console.error(`Thumbnail generation failed for ${jobId}:`, err);
    }
  }

  private isRateLimitError(message: string): boolean {
    return message.toLowerCase().includes('rate limit') || message.includes('429');
  }

  private isServerError(message: string): boolean {
    return message.includes('Status: 500') || message.toLowerCase().includes('internal server error');
  }

  /**
   * Periodic watchdog to kick the queue if it ever stalls
   */
  private startQueueWatchdog() {
    if (this.queueWatchdogStarted) return;
    this.queueWatchdogStarted = true;

    const timer = setInterval(async () => {
      try {
        if (this.queueLoopRunning) return;
        const queuedCount = await this.prisma.researchJob.count({
          where: { status: 'queued' }
        });
        if (queuedCount > 0) {
          this.processQueue(true).catch(console.error);
        }
      } catch (err) {
        console.error('Queue watchdog error:', err);
      }
    }, 10000); // every 10s
    timer.unref?.();
  }
}

// Singleton accessor so queue processor is shared
let orchestratorSingleton: ResearchOrchestrator | null = null;
export function getResearchOrchestrator(prisma: PrismaClient): ResearchOrchestrator {
  if (!orchestratorSingleton) {
    orchestratorSingleton = new ResearchOrchestrator(prisma);
  }
  return orchestratorSingleton;
}
